https://learnblockchain.cn/article/1554



## 迪菲-赫尔曼密钥交换



其实跟咱们日常生活中使用的锁和钥匙原理差不多的东西——迪菲-赫尔曼密钥交换（Diffie-Hellman key exchange），简称D-H。这个协议就像是两个人在没有密封信封的情况下，如何安全地交换他们之间的秘密一样。这个协议的目标就是让通信的两方最终得到一把一模一样的密钥，也就是你手里那把能打开锁的钥匙，只不过这里的锁和钥匙都是数字形式的。

想象一下，Alice和Bob想在一个充满窃听者的网络中安全地聊天（网络里总有那么一些好奇的眼睛和耳朵，比如我们的坏蛋Eve）。他们需要一种方法来确保他们之间的对话不被Eve听到。这时候D-H协议就派上用场了。

首先，他们得同意使用一套数学规则，这套规则在数学上被称作有限循环群，可以简单理解为一个数字的轮盘，转来转去但又有一定的限制。他们也得选一个公开的数字作为起点，我们称它为生成元，这就像是他们公认的起跑线。

接下来，Alice选一个只有她知道的随机数，我们叫它a，她把这个数字与起点相结合（数学上叫做模幂运算），然后得到一个结果，这个结果是可以公开的，所以她大大方方地发给Bob。Bob也做同样的事，他选一个只有他知道的随机数b，结合起点，然后得到一个结果发给Alice。

现在，Alice和Bob都有了对方的公开结果和自己的私密数字。Alice拿到Bob的公开结果，用她自己的私密数a再做一次结合运算，得到一个新的结果。Bob也是这样，他用Alice发给他的公开结果和自己的私密数b做结合运算。咦，神奇的事情发生了，两人得到了相同的结果！这个结果就是他们的秘密密钥，可以用来加密他们的对话了。

这听起来是不是有点像魔法？其实这里面有数学的巧妙之处。在数学上，这个过程就像是两个人分别在自己的秘密房间里面，用自己的私密数字对一个公共物品进行了某种"魔法"变换，最后得出了完全相同的东西。这个"魔法"就是前面提到的有限循环群和生成元，以及模幂运算的特性。

来个简化版的例子吧。假设有限循环群的轮盘上数字是从1到28，并且我们选了个数字3作为起点。Alice随机挑了个4，Bob挑了个7。Alice的运算结果是23，Bob的是12。然后Alice用12跟自己的秘密数4做同样的运算，得到了1。Bob也用23和自己的秘密数7做运算，也得到了1。这个1，就是他们的共享秘密了。

不过，我们得提一下，这个过程虽然能让Alice和 Bob共享秘密，但如果有个中间人Eve在他们交换公开结果的时候截获了信息，她也可以Oops, looks like I got a bit carried away and didn't finish that last sentence. Let's wrap that up:

如果有个中间人Eve在Alice和Bob交换公开结果的时候截获了信息，理论上她也可以尝试去计算出他们共享的秘密。但是，由于Diffie-Hellman协议基于的数学难题是离散对数问题，对于足够大的数字来说，即使Eve得到了公开的信息，要计算出共享秘密也非常困难，因为这个问题在数学上是非常难解的。这就像是试图在一个巨大的数字轮盘上反向追踪，而这个轮盘大到令人难以想象，以至于找到正确的数字几乎是不可能的。

因此，尽管Diffie-Hellman密钥交换并不是完全安全的——比如，它容易受到中间人攻击，如果交换过程中的信息被篡改，Alice和Bob可能会和中间人而不是彼此建立共享秘密——它仍然是一个非常强大的工具，因为它允许在不安全的通道上建立安全的通信。这种方法现在仍然被广泛用于互联网安全协议中，像是HTTPS、SSH和IPsec等。

总的来说，Diffie-Hellman密钥交换是密码学史上的一个创新点，它让我们能够在充满监听风险的环境中安全地交换密钥，而无需事先共享秘密。







Diffie–Hellman key exchange，缩写为D-H， 是一种安全协议，用于双方在一个不安全的通信网络上建立一个 共享的秘钥，有了共享秘钥以后，就可以使用这个密钥加密交互消息。由于通信双方最终使用的密钥相同，所以可以认为该协议目标是创建一个对称密钥（对称密钥和非对称密钥可自行学习）。该协议也称迪菲－赫尔曼密钥协商，名字以发明人的名字命名，符合惯例，无其他特殊意义。

迪菲－赫尔曼密钥交换本身是一个匿名（无认证）的密钥交换协议，它却是很多认证协议的基础，并且被用来提供传输层安全协议的短暂模式中的前向安全性。

## **密钥交换（创建）过程**

假设A，B两人通信，约定使用同一个有限循环群G和它的一个生成元g。一般过程如下：

1. A选择一个随机正整数a，计算= mod p发送给B。
2. B选择一个随机正整数b，计算= mod p发送给A。
3. A收到B消息后 计算R1= mod p
4. B收到A消息后 计算R2= mod p
5. 由于r1==r2,所以得到同一个值，作为共同的密钥。

为什么r1==r2? 可以推导如下： R1= mod p  == mod p= mod p R2= mod p  == mod p= mod p

得到R1==R2， 这里用到了指数模运算的性质（下一节将详细介绍模运算规则）。 于是，A和B就同时协商出一个新的群元素，它可以被用作共享秘密。因为群是乘法交换的。

## **实例演练**

假定 在模素数29有限域上 g=3, p=29 A 秘密选择随机数a=4,B秘密选择随机数b=7,

1. A计算: = mod p= mod 29 =23 发给B
2. B计算: = mod p= mod 29 =12 发给A
3. A收到后计算 R1= mod p = mod 29= 1
4. A收到后计算 R2= mod p = mod 29= 1 R1=R2,很巧选取的数据得到的结果的1.

椭圆曲线上应用迪菲-赫尔曼密钥交换的算法与上述有点不同，椭圆曲线上没有点的幂运算，取而代之的是点的标量乘法运算， 这一点在之前文章有所提及**椭圆曲线上的指数运算**

1. A生成私钥a，将它乘以基点G得到公钥，即 a *G= 发给B
2. B生成私钥b，将它乘以基点G得到公钥，即 b *G= 发给A
3. A计算 ( , ) = a *， 即为交换得到的密钥。
4. B计算 ( , ) = b *， 即为交换得到的密钥。

结果显而易见,注意实际用到的密钥协商算法参数是严格选取的大整数，例子中只是作为原理说明。现实中密钥交换算法是与其他加密算法一起使用，如RSA_DH, EC-DH,  其实对应了上面列举的两个例子。 实际编程中，密钥交换已经有实现完整的库可以用。例如Java中 KeyAgreement等。



## **安全性**

迪菲－赫尔曼密钥交换本身并没有提供通讯双方的身份验证服务，所以有可能会被中间人攻击。一个中间人在信道的中间分别和 A，B 进行两次迪菲－赫尔曼密钥交换，就能够成功的向A假装B，向B假装A。此时攻击者可以读取任何一个人的信息并重新加密信息，然后传递给另一个人。因此通常都需要一个能够验证通讯双方身份的机制来防止这类攻击。有很多种安全身份验证解决方案使用到了迪菲－赫尔曼密钥交换。当A和B共有一个公钥基础设施时，他们可以将他们的返回密钥进行签名；STS以及IPsec协议的IKE组件已经成为了Internet协议的一部分。

由于密码学中大量用到模运算，之前很多文章大都提到，下一节将总结模运算下的各种运算规则。



