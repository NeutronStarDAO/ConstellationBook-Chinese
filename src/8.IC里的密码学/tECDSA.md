我们提出并分析了一种新的协议，该协议提供了分布式的 ECDSA 签名服务，具有以下特性：

* 它在异步通信模型下工作；
* 它适用于 n 方参与者，最多允许 f < n/3 的拜占庭故障；
* 它提供了保证的输出传递；
* 它提供了非常高效的非交互式在线签名阶段；
* 它支持根据 BIP32 标准进行附加密钥派生。

尽管近年来关于分布式 ECDSA 签名协议的研究如雨后春笋，但这些新设计的协议都没有在异步通信网络上提供保证的输出传递；此外，我们的协议在渐近通信和计算复杂性方面的性能要么达到，要么超越了其他协议的性能。

这项服务正在被实施并集成到 Internet Computer 的架构中，使运行在 Internet Computer 上的智能合约能够安全地持有和使用比特币等加密货币。

在此过程中，我们还介绍了一些独立有趣的结果：

* 一种新的异步可验证秘密共享（AVSS）方案，简单且高效；
* [一种新的多接收者加密方案，同样简单且高效](https://eprint.iacr.org/2022/506.pdf)



## 简介

ECDSA（椭圆曲线数字签名算法）[NIST13]是一种标准且广泛使用的签名方案。近年来，主要受区块链应用驱动，对于ECDSA签名的分布式协议进行了大量研究[AHS20]。这些协议主要提供了分布式的ECDSA签名服务，其目标是消除单一的漏洞点。由于ECDSA签名方案在区块链应用和其他领域中发挥着重要作用，基于ECDSA设计实用的分布式签名服务是一个重要目标，尽管基于其他签名方案（尤其是BLS方案[BLS01, Bol03]）设计实用的分布式签名服务要容易得多。



在本文中，我们提出并分析了一种新的协议，该协议提供了分布式的ECDSA签名服务，具有以下特性：

1. 它假设一个异步通信模型，对于在各方之间传递消息所需的时间没有先验限制。
2. 它假设有一个包含n个参与方的网络，最多有f < n/3个拜占庭故障。
3. 它假设存在一个公钥基础设施，每个参与方生成自己的公钥/私钥对，并知道所有其他参与方的公钥，以及一个公共参考字符串（由一个离散对数未知的群元素组成）和一个用于模拟密码哈希函数的随机预言。
4. 它利用共识子协议以及一个随机灯塔（beacon）。
5. 它保证安全性，意味着对手只能获得被诚实方请求的签名。
6. 它提供了保证的输出传递，意味着所有签名请求将被满足，并且生成的签名将被传递给诚实方（在诚实方之间的所有消息最终都会被传递，共识子协议提供活力的情况下）。
7. 它提供了非常高效的、非交互式的在线签名阶段，意味着在适当的消息独立预计算的情况下，对于签名请求，每个参与方只需广播一个“签名份额”，并收集足够数量的这种“签名份额”来计算签名；特别地，（较昂贵的）共识子协议在在线签名阶段是不需要的。
8. 它支持BIP32风格的可加密派生密钥[Wui20]，这意味着可以轻松从单个签名密钥以分层方式派生许多签名密钥。

我们的协议正在被实施并集成到互联网计算机的架构中[DFI22]。互联网计算机本质上是一组通信的复制状态机，其中每个这样的状态机都实现为运行基于区块链的共识协议的节点网络[CDH+21]。我们新的分布式ECDSA签名协议的共识子协议直接使用互联网计算机的基于区块链的共识协议实施。

随机灯塔是一种获取在协议确定的时间之前保持不可预测的公共随机值的机制。互联网计算机架构已经实现了这样的机制，我们签名协议的实现利用了这一点。



我们在UC框架[Can00]中对我们的协议进行了安全性分析，表明它等效于生成ECDSA签名的理想功能。这个安全性证明基于椭圆曲线离散对数问题的相当标准的密码学假设，并将某些哈希函数建模为随机预言（它不依赖于与因子分解有关的任何假设）。因此，我们分布式签名服务的防伪性质被归结为在具体攻击模型下分析详细内容的伴随论文[GS21]中ECDSA签名的防伪性质。



### 关于通信模型和共识的更多内容

在设计和分析任何分布式协议时，必须指定一个通信模型，该模型描述对手延迟在副本之间传递消息的能力。在光谱的两端，我们有以下模型：

• 在同步模型中，存在某个已知的有限时间界限 δ，以便对于发送的任何消息，它将在不到时间 δ 的时间内被传递。

• 在异步模型中，对于发送的任何消息，对手可以延迟其传递的时间量，因此没有关于传递消息的时间的界限。

为了获得高度分散和安全的协议，我们主要关注的是其节点分布在全球各地的网络，对于这样的网络，同步通信模型将是极不现实的。实际上，攻击者可以通过延迟诚实节点或它们之间的通信来破坏协议的正确行为。这种攻击通常比获取对和腐化诚实节点的控制更容易实施。

共识是许多分布式协议中核心的基本问题。实际上，任何分布式签名协议都必须将分布式密钥生成协议作为子协议，而这本身是共识的一种特殊情况，因为所有参与方至少都必须生成并同意签名方案的公钥。

对于我们新的分布式签名协议，共识问题有不同的表述，我们需要的是称为“对共同子集的一致性”（ACS）的一种。在ACS协议中，每个参与方向协议提供一个输入，并将一个输入子集作为输出。重要的是，所有诚实的参与方必须获得相同的子集。子集的大小由协议的大小参数 k 决定，其中 k ≤ n − f。只要所有参与方都参与协议，它们之间的所有消息最终被传递，所有诚实的参与方都应最终获得此子集。还可以强加外部有效性条件，协议确保每个输入都满足此条件。

ACS问题首次在[BKR94]中定义和研究。虽然这项工作提供了理论上的概念证明，但由此产生的协议并不实用。更近期的工作[MXC+16，DRZ18，GLT+20]在实现更实用的ACS协议方面取得了巨大进展。不幸的是，虽然这些协议取得了相当令人印象深刻的吞吐量，但它们仍然没有提供很好的延迟。

在将我们新的分布式签名协议集成到互联网计算机中时，我们使用了互联网计算机中已经实现的共识协议来实现ACS。与大多数其他实用的拜占庭容错共识协议一样，互联网计算机的共识协议[CDH+21]不依赖于同步通信（例如[CL99，BKM18，YMR+18]），而是依赖于部分同步通信模型[DLS88]。这种部分同步模型可以以不同的方式表述。互联网计算机使用的部分同步假设大致说，通信在短时间间隔内周期同步；此外，消息传递的同步边界 δ 无需事先知道。

这种部分同步假设仅用于确保共识协议取得进展（所谓的“活力”属性）。它不是确保共识正确行为（所谓的“安全”属性）的必要条件，也不是互联网计算机协议栈中的任何其他地方的必要条件。在部分同步和拜占庭故障的假设下，已知对于故障数量 f，f < n/3 的界限是最优的。

尽管我们的ECDSA签名协议在我们对共识的特定实现中间接依赖于部分同步的假设，但我们认为最好不要在共识之外依赖此类假设，有几个原因。首先，构建一个依赖部分同步的共识协议，并且当该假设开始失败（可能是间歇性的）时可以平稳退化，这是一项具有挑战性的工程任务，最好将此问题隔离到共识层。其次，随着纯异步共识协议的不断改进，使用这样的协议可能变得实际，尤其是因为共识仅在预计算阶段需要，而不是签名阶段，而其中低延迟至关重要。

#### 鸡和蛋问题

在纯异步通信模型中，实际上用于共识的最实用协议（例如[MXC+16，DRZ18，GLT+20]）实际上需要一个“特殊设置”来为一个或多个阈值密码方案提供密钥，而不是使用公钥基础设施的“标准设置”。在其他方面，这些阈值方案被用于实现随机灯塔，如[CKS00]中提出并在[MXC+16，DRZ18，GLT+20]中使用的那样。例如，可以使用阈值BLS签名来高效实现随机灯塔。这种特殊设置可以通过使用一次性、可信任的集中式密钥配置步骤来完成，但从安全性的角度来看，这显然是不可取的，因为它会创建一个单一的漏洞点。我们更愿意使用分布式密钥生成协议来执行此设置。如前所述，分布式密钥生成本身就是一种共识问题，因此我们似乎有一个“鸡和蛋”的问题。为了解决这个问题，可以使用一种使通信假设更强（例如部分同步）和/或效率较低的分布式密钥生成协议来执行特殊设置。例如，[KHG12]提供了一个相当实用的分布式密钥生成协议。该协议建立在[CKLS02]的异步可验证秘密共享方案和[CL99]的PBFT共识协议的变体之上，该共识协议对于活力假设部分同步，但不需要特殊设置。可以将[KHG12]中的PBFT共识协议替换为没有特殊设置的纯异步共识协议，例如[BKR94]中的协议，但这将导致一个非常不实用的协议。最近，在论文[KMS20，AJM+21]中，这个“鸡和蛋”问题已经得到了更为令人满意的解决，直接解决了异步分布式密钥生成问题，而无需经过单独的共识子协议，从而得到了迄今为止对于这个问题最实用的协议。

除了共识，我们的ECDSA签名协议直接利用了一个随机灯塔。这个随机灯塔对于核心的ECDSA签名协议并非必不可少，但它允许我们在将BIP32风格的可加密密钥生成与非交互式在线签名相结合时实现更好的具体安全性边界。如前所述，我们在互联网计算机上实现的ECDSA签名协议利用了后者已经实现的随机灯塔。这个随机灯塔是使用阈值BLS签名实现的。对于这些阈值BLS签名，互联网计算机需要一个分布式密钥生成协议。该密钥生成协议本身使用共识。通过以“引导模式”运行互联网计算机的共识协议来解决这个“鸡和蛋”问题，在这种模式下，它在没有随机灯塔的情况下运行，但（可能）性能下降。

#### 相关工作

ECDSA签名方案在结构上与早期的DSA签名方案[NIST13]非常相似，而DSA签名和相关问题的分布式协议在[GJKR96, GJKR99, GJKR01, GJKR03]中进行了研究。如前所述，近年来对ECDSA签名的分布式协议引起了广泛关注。参见优秀的综述[AHS20]。与其将我们的工作与[AHS20]中讨论的所有协议进行比较，我们将关注四项代表性的最近工作[CMP20, GKSS20, DJN+20, GG20]。 

预计算和在线签名阶段。我们的协议，像[CMP20, GKSS20, DJN+20, GG20]中的所有协议一样，消耗独立于输入的“签名辅助”，每个签名请求一个。生成这些“签名辅助”通常被称为“预计算阶段”，但对于长寿命的分布式签名服务，这是一个持续的过程。理想情况下，可以生成稳定的“签名辅助”供应，以便当签名请求到来时，有一个这样的“签名辅助”可用，并且可以以非常高效的方式在线处理签名请求。实际上，[CMP20, DJN+20, GG20]中的协议都具有非交互式的在线签名阶段，这意味着对于签名请求，如果“签名辅助”可用，每个参与方只需广播一个“签名份额”，并在获得足够的份额后可以计算出签名。我们的协议也具有相同的属性。

腐败限制。我们的协议假设最多有 f < n/3 个腐败方。[DJN+20]中的协议假设 f < n/2 个腐败方。[CMP20, GG20]中的协议允许任意数量的腐败方。[GKSS20]中的协议略为更通用：它允许任意的重构阈值 1 ≤ t ≤ n，因此最多 t − 1 个方可腐败，至少 t 个诚实方必须参与在线签名阶段。

通信模型。[CMP20, GKSS20, DJN+20, GG20]中的所有协议，实际上所有在综述论文[AHS20]中讨论的协议，以及[GJKR96, GJKR99, GJKR01, GJKR03]中的较旧协议，都假设同步通信模型。如第1.1节所述，我们发现这个模型对于节点分布在全球的高度分散网络而言相当不现实。论文[KHG12]也阐述了为什么在这种情况下同步通信是不现实的。

保证输出传递。[CMP20, GKSS20, DJN+20, GG20]中的所有这些协议都缺乏保证输出传递。特别是，如果网络中的单个节点在一段时间内失去网络连接（或崩溃），它们可能会完全停止。由于[CMP20, GG20]中的协议与诚实方的数量成反比，因此它们无法提供保证输出传递（甚至公平性）。请注意，[GG20]中的协议提供了一种称为“可识别中止”的安全属性，它基本上意味着如果协议未能向所有诚实方生成输出，则将可靠地识别出一个腐败方（这个概念早在[IOZ15]中就进行了研究）。不幸的是，“可识别中止”的概念无法转化为异步通信模型，因为无法区分无响应的腐败方和具有缓慢网络连接的诚实方。

尽管[GKSS20, DJN+20]中的协议确实在在线签名阶段提供了保证的输出传递（对于[GKSS20]，如果至少有t个诚实方可用的话），但在预计算阶段却没有这样做。对于这些协议，如果仅有一个节点在足够长的时间内离线，将导致“签名辅助”的供应完全耗尽，签名生成将停滞不前。其他最近用于一般异步多方计算（MPC）的协议，如[LYK+19]，也可以用于实现分布式ECDSA签名服务，同样具有在线阶段有保证的输出传递但在预计算阶段没有的不幸属性。相比之下，我们的协议仅假设异步通信模型，并在预计算阶段和在线签名阶段均提供了保证的输出传递。

通信成本。如前所述，在在线签名阶段，我们的协议仅需要一轮通信，就像[CMP20, DJN+20, GG20]中的协议一样。在预计算阶段，我们的协议只需要恒定数量的通信轮次。

我们还考虑了我们协议的通信复杂性，即所有诚实方P和所有方Q在每个签名请求中从P发送到Q的比特数之和（并在许多签名请求中进行了摊销）。此外，我们区分“快乐路径”，其中没有一方可以被证明行为不当，以及“不快乐路径”，其中某些方可以被证明行为不当。可以说，实际上，专注于“快乐路径”是有道理的，假设可以迅速将被证明行为不当的方从网络中排除（可能以其他方式受到惩罚）。 （请注意，即使在“不快乐路径”上，我们的协议仍然保证输出传递，尽管可能效率较低。）

我们协议在线签名阶段的通信复杂性（在“快乐路径”和“不快乐路径”上）为O(n2λ)。在这里，λ是一个安全参数，它限制了签名、哈希、群元素等的大小。此界限与[CMP20, GKSS20, DJN+20, GG20]中的协议的在线通信复杂性相匹配。

对于我们协议预计算阶段，在“快乐路径”上的通信复杂性为O(n2λ)，而在“不快乐路径”上的通信复杂性为O(n3λ)。至少在“快乐路径”上，这些界限与[CMP20, DJN+20, GG20]的界限相匹配。我们还注意到，[CMP20, GG20]中的协议依赖于Paillier加密[Pai99]，这意味着通信复杂性中的λ值明显更高（通常高出大约10倍），而不像我们的协议等不依赖于此的协议。

[GKSS20]中的协议预计算阶段的通信复杂性依赖于该论文未提供的一些细节，因此我们没有进行比较。

计算成本。我们考虑我们协议的计算复杂性，即每个签名请求中每个诚实方的运行时间的最大值（在许多签名请求上摊销）。与前面一样，我们区分“快乐路径”和“不快乐路径”。

我们协议在线签名阶段的计算复杂性（在“快乐路径”和“不快乐路径”上）为~O(n)数量级的标量运算。相比之下，[CMP20, DJN+20, GG20]中协议的在线签名阶段执行O(n)数量级的标量运算加上O(1)数量级的指数运算。

对于预计算阶段，我们协议在“快乐路径”上的计算复杂性主要由O(n)数量级的指数运算支配。在“不快乐路径”上，这个成本可能增加到O(n2)数量级的指数运算（再加上O(n3)数量级的“短”指数运算，通常对于适度大小的n来说不会支配成本）。

[DJN+20]中的协议预计算阶段执行O(n)数量级的“指数插值”，每个插值需要O(n)数量级的指数运算（实际上是长度为O(n)的一次性指数运算，成本略低于O(n)数量级的指数运算）。因此，至少在展示的形式下，他们的协议需要O(n2)数量级的指数运算，这明显比我们协议在“快乐路径”上的计算成本更差。尽管如此，似乎可以优化他们的协议，将其复杂性减少到接近我们协议的水平。

[CMP20, GG20]中协议的预计算阶段每个签名请求只执行O(n)数量级的指数运算。然而，这包括与Paillier加密相关的群中的O(n)数量级的指数运算。由于在该群中进行指数运算的成本非常高，这些协议的计算成本将明显高于我们协议的计算成本。

[GKSS20]中的协议的计算复杂性依赖于该论文未提供的一些细节，因此我们没有进行比较。

静态与自适应腐败。我们的协议以及[GKSS20, DJN+20, GG20]中的协议在假设静态腐败的情况下进行分析。[CMP20]中的协议在假设自适应腐败的情况下进行分析。然而，我们对自适应腐败情况下的协议安全性进行了简要勾画，基于对ECDSA签名方案的更强（但仍合理）的假设。

主动安全性。[CMP20]中的协议明确提供主动安全性，其中定期将各方重启到原始状态，并且只要在任何时刻腐败的方不太多，安全性就保持，即使最终所有方都可能被腐败。我们还简要勾画了我们的协议如何部署以提供主动安全性。

#### 其他相关工作

在[RRJ+22]中也注意到了设计在异步通信模型中提供保证输出传递的分布式签名服务的重要性（该工作在此工作公开后不久发布）。[RRJ+22]中的协议是针对Schnorr签名而不是ECDSA签名的分布式签名服务。他们的协议基于与我们完全不同的设计原则。与我们的协议不同（请参见第2.6.4节），他们的协议可能允许对每个签名请求获取多个不同的签名。因此，即使Schnorr签名方案提供了强大的不可伪造性，这种特性在他们的协议中也会丢失。对于某些应用，这种特性可能很重要。与我们的协议不同，他们的协议也不依赖于共识子协议。









AI：

关于论文中Sharings and interpolation和Dealings and packages of dealings部分的详细解释如下:

Sharings and interpolation部分:

1. 分享的结构包括公共数据(所有方同意的)和私有数据(每个方持有的"份额")。公共数据包括标识符sharingID和多项式承诺C。私有数据为每个方Pj的(μj, μ'_j),满足C(j)=g^μj*h^μ'_j。 

2. 插值算法interp用于将一组点(i, νi)恢复出一个多项式的值。interp2用于从一组点(i, νi, ν'_i)恢复出两个多项式的值。interpExp用于从一组点(i, vi)恢复出bases vi的指数多项式的值。

3. 这些插值算法可以恢复出秘密分享多项式在某个点上的的值,是实现Open和OpenPower子协议的基础。

Dealings and packages of dealings部分:

1. Dealing表示经过加密的秘密份额,包括标识符、提交方身份、多项式承诺、加密后的份额等。

2. Dealing generation算法用于由一个方生成dealing。它包含生成随机多项式、计算承诺、使用MEGa加密份额等步骤。

3. Dealing authenticator包含dealing的hash和签名,用于验证dealing的正确性。

4. 各方可以本地验证dealing是否正确解密。如果正确,可以发送dealing verification share。 

5. 提交方可以收集足够数量的verification share并生成dealing verification certificate。

6. 使用一个共识子协议,各方可以就一个package of dealings达成一致。

7. 最后,各方可以利用这些经验证的dealings来计算自己的秘密份额,并执行插值计算恢复最终的共享秘密。

综上,Sharings and interpolation部分定义了表示分享的语法和恢复分享值的插值算法;Dealings and packages of dealings部分定义了表示经加密分享的dealing的语法,以及验证和组合这些dealing来恢复共享秘密的过程。两者互为基础,共同实现了基于多项式秘密分享和MEGa加密的阈值ECDSA签名方案。

关于阈值ECDSA签名方案的密码学原理可以总结如下:

1. 使用Shamir秘密分享,将ECDSA签名私钥α以多项式形式分散给n个参与方,每个参与方持有自己的份额。

2. 为提高效率,可以预先计算签名辅助数据(presignature),包括R=g^κ。

3. 对于消息m的签名请求,参与方利用自己的份额、随机数和预计算的值,可以本地计算出分签名份额σi。

4. 收集到足够数量的分签名份额后,可以计算出最终的签名(ρ,σ)。

5. 该方案可以证明在随机预言机模型下达到阈值签名的可安全性。安全性依赖Discrete Logarithm问题的困难性以及Hash函数的预像抵抗性。

6. 通过引入重新随机化的presignature,可以抵抗因预计算导致的安全性下降。

7. 批处理技术可以进一步优化通信和计算复杂度。

总体来说,该方案将ECDSA签名私钥以多项式形式分散存储,通过预计算和本地计算优化效率,并引入重新随机化和批处理等技术增强安全性,在保证安全性的前提下实现了高效的阈值ECDSA签名。





关于论文中提到的阈值ECDSA签名的密钥分发和签名过程,可以详细解释如下:

一、密钥分发

1. 每个参与方Pi生成密钥对(pki,ski),pki为公钥,ski为私钥。

2. 每个参与方都将自己的公钥pki以广播的方式发送给其他所有参与方。

3. 每个参与方Pi将所有参与方的公钥pk1,...,pkn记录下来。

4. 使用pedersen可验证密钥分发方案分发ECDSA签名私钥α。

5. 每个参与方Pi以多项式的形式生成自己对α的份额μi,并生成承诺C。 

6. 每个参与方Pi将自己的份额μi以及承诺C发送给其他参与方。

7. 各参与方验证份额μi是否正确,如果正确则回复验证信息。

8. 收集到足够数量的验证信息后,确认份额分发正确完成。

9. 公钥u = g^α通过Open算法计算并发布。

二、签名

1. 预计算:随机选择κ,计算R=g^κ,以及α·κ等价的份额。

2. 对消息m计算hash φ = H(m)。

3. 每个参与方Pi利用自己的份额μi、随机数ri以及预计算值,计算签名份额σi。

4. 每个参与方Pi将自己的签名份额σi广播给其他参与方。 

5. 收集到足够数量的签名份额σi后,可以计算出ρ和σ,形成签名(ρ,σ)。

6. 验证方利用公钥u、消息m以及签名(ρ,σ)可以验证签名的正确性。

综上,阈值ECDSA签名先利用多项式秘密分享 securely分发私钥α,然后各参与方利用自己的份额协作签名,并可以验证签名的正确性,从而实现了安全可靠的分布式ECDSA签名。