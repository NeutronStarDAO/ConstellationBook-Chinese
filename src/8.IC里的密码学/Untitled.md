https://juejin.cn/post/7118221301986115591

BLS：

https://mp.weixin.qq.com/s?__biz=MzA5NzI4MzkyNA==&mid=2247484307&idx=1&sn=74746c1be36e51e49ec6282d14db60b0&scene=21#wechat_redirect

https://mp.weixin.qq.com/s?__biz=MzA5NzI4MzkyNA==&mid=2247484314&idx=1&sn=011df46da3c8d6df2f5be1e3eb5f8672&scene=21#wechat_redirect

https://mp.weixin.qq.com/s?__biz=MzA5NzI4MzkyNA==&mid=2247484374&idx=1&sn=e926a47ee765ce9e73ffb13aebec34eb&chksm=90a279eda7d5f0fbb52393bac6bb69c07828a6176412397f8c93fcfb2ca012d36566c209abbf&cur_album_id=1648092557035241479&scene=189#wechat_redirect

https://mp.weixin.qq.com/s/ymElad5WmXAbvgklxVKL-g

https://blog.csdn.net/weixin_39928818/article/details/113317367

https://blog.csdn.net/mutourend/article/details/121199130

https://blog.csdn.net/Sanayeah/article/details/111423092

https://blog.csdn.net/mutourend/article/details/121199130

https://zhuanlan.zhihu.com/p/63734137?utm_id=0

https://zhuanlan.zhihu.com/p/571805820

https://blog.csdn.net/Lisa_8888888/article/details/103916637

https://blog.csdn.net/Sanayeah/article/details/115062129

https://mp.weixin.qq.com/s?__biz=MzU5MzMxNTk2Nw==&mid=2247484583&idx=1&sn=838d95bdf8fe942df4b74de4b77ad6c5&chksm=fe1315b7c9649ca172fe2e58b9930b7381571d0aa6f06b07bdaa59d00c3fa7ada0bd2f02922f&scene=21#wechat_redirect

https://blog.csdn.net/mutourend/article/details/106796297





数字证书

数字证书是一种权威的电子证明，由权威公正的第三方证书颁发机构（CA）签发，用来证明公钥拥有者的身份。数字证书中包含了公钥信息、拥有者身份信息，以及 CA 对这份文件的数字签名，用以保证这份文件的整体内容正确无误。数字证书被广泛用于需要身份验证和数据安全的领域，简单来说就是数字证书能够证明这个公钥被谁拥有。数字证书主要用来保证信息保密、身份确认、不可否认性和数据完整性，常见的格式是 X.509 格式。

用户想要获得数字证书，应该先向 CA 提出申请，CA 验证申请者的身份后，为其分配一个公钥并且与其身份信息绑定。CA 为该信息进行签名，作为数字证书的一部分，然后把整个数字证书发送给申请者。



Hash 后的摘要

当需要鉴别数字证书的真伪时，只需要用 CA 的公钥对数字证书上的签名进行验证即可，验证通过则证明数字证书有效。

数字证书结构

数字证书的结构一般采用X.509格式，X.509格式使用 ASN.1(Abstract Syntax Notation One）抽象语法标记来表示。ASN.1是一种由国际标准组织（ISO/ITU-T）制定的标准，描述了一种对数据进行表示、编码、传输和解码的数据格式，用于实现平台之间的互操作性。X.509 格式的数字证书结构如图1-4所示。

版本(Version)

序列号(Serial Number)

使用CA的私

签名算法(Signature Algorithm)

钥进行加密

颁发者（Issuer)

有效期（Validity)

主体名(Subject Name)

公钥信息(Subjecl Publlc Key Info)

扩展信息（Extensions)

签名(Signature)



图1-4X.509格式的数字证书结构

在X.509格式的数字证书中，各个字段含义如下。

·版本：数字证书使用X.509规范的版本，目前普遍使用 v3 版本。

·序列号：CA会为每个颁发的数字证书分配一个整数，作为数字证书的唯一标识。

·签名算法：CA颁发数字证书使用的签名算法。

·有效期：包含数字证书的起止日期。

·主体名：该数字证书拥有者的名称，如果与颁发者相同，则说明该数字证书是一个

自签名证书。

·公钥信息：对外公开的公钥及所使用的公钥生成算法。



扩展信息：通常包含数字证书的用法、证书吊销列表（Certificate Revocation List,CRL）的发布地址等可选字段。

签名：颁发者用私钥对数字证书信息的签名。



## 数字证书编码

数字证书在计算机中的表示方法有所不同，但是都是可以相互转换的，常见的编码格式为 PKCS#12 、DER 和 PEM 。

PKCS 标准是指由 RSASecurity 设计和发布的一组公钥加密标准。因此，RSASecurity 及其研究部门 RSALabs 有义务促进公钥技术的使用。为此，他们（从 20 世纪 90 年代初开始）开发了 PKCS 标准，并保留了对 PKCS 标准的控制权，宣布他们会在自己认为必要的时候进行改变或改进，因此，PKCS 标准在重要意义上并不是真正的行业标准，尽管名称如此。对于 PKCS 标准，常见的是标准 PKCS#12 ，其中 #12 是标准编号，文件后缀是 P12 。

DER（可分辨编码规则）是一种用于存储 X.509 证书文件的流行编码标准。ASN.1 的可分辨编码规则是根据 X.509 规范对 BER 编码的约束得出的国际标准。DER 编码是有效的 BER 编码。DER 编码与 BER 编码相以，只是删除了一个发送者的选项。例如，在 BER 编码中，布尔值 true 可以用 255 种方式编码，而在 DER 编码中，只有一种方法可以编码布尔值 true 。DER 编码的完整规范在 RFC1421 中。

X.509 证书文件最常用的编码方案是 PEM（隐私增强邮件）编码。PEM 编码的完整规范在 RFC 1421中。在 X.509 证书文件上进行 PEM 编码的想法非常简单：使用 Base64 编码对内容进行编码。编码后的文件后缀通常为 PEM ，将 Base64 编码输出括在两行之间：“-..- BEGIN CERTIFICATE ---” 和 “ …. END CERTIFICATE-- ” ，下面的例子是 PEM 编码的 X.509 证书结构示例。

-----BEGIN CERTIFICATE--

MIICSTCCAfWgAwIBAgIBATAKBggqhkjOPQQDAjBOMQkwBwYDVQQIEwAxCTAHBqNV BAcTADEJMAcGAlUECRMAMQkwBwYDVQQREwAxDjAMBgNVBAoTBWZsYXRvMQkwBwYD VQQLEwAxDjAMBgNVBAMTBW5vZGUyMQswCQYDVQQGEwJaSDEOMAwGAlUEKhMFZWNl cnQwIBcNMjAwNTIxMDUlMTEOWhgPMjEyMDAOMjcwNjUxMTRaMHQxCTAHBgNVBAgT ADEJMAcGAlUEBxMAMQkwBwYDVQQJEwAxCTAHBgNVBBETADEOMAwGAlUEChMFZmxh dG8xCTAHBgNVBAsTADEOMAwGAlUEAxMFbm9kZTExCzAJBgNVBAYTAlpIMQ4wDAYDVQQqEwVlY2VydDBWMBAGByqGSM49AgEGBSuBBAAKAOIABBI3ewNK21vHNOPG6U3X mKJohSNNz72QKDxUpRtOfCJHwaGYfSvY4cnqkbliclfckUTpCkFSRr4cqN6PURCF zkWjeTB3MA4GAlUdDwEB/wQEAwIChDAmBgNVHSUEHzAdBggrBgEFBQcDAgYIKwYB BQUHAwEGAioDBgOBCwEwDwYDVROTAQH/BAUwAwEB/zANBqNVHQ4EBqQEAQIDBDAP BgNVHSMECDAGgAQBAgMEMAwGAypWAQQFZWNlcnQwCgYIKoZIzjOEAwIDQgB3Cfo8/Vdzzlz+MW+MIVuYQkcNkACY/yU/IXD1sHDGZQWcGKr4NR7FHJgsbjGpbUiCofw4 4rK6biAEEAOcv1BQAA==

----END CERTIFICATE---

DER 编码的 X.509 证书文件是二进制文件，无法使用文本编辑器查看，但几乎所有应用程序都支持 DER 编码的证书文件。DER 编码的证书文件的文件扩展名为 “ .cer ” “ der ” “ .crt ” 。





X.509 是常见通用的证书格式。所有的证书都符合为 Public Key Infrastructure（PKI）制定的 ITU-T X509 国际标准。X.509 是国际电信联盟-电信（ITU-T）部分标准和国际标准化组织（ISO）的证书格式标准。作为 ITU-ISO 目录服务系列标准的一部分，X.509 是定义了公钥证书结构的基本标准。1988 年首次发布，1993 年和 1996 年两次修订。当前使用的版本是 X.509 V3 ，它加入了扩展字段支持，这极大地增进了证书的灵活性。X.509 V3 证书包括一组按预定义顺序排列的强制字段，还有可选扩展字段，即使在强制字段中，X.509 证书也允许很大的灵活性，因为它为大多数字段提供了多种编码方案。





1.10.4简单应用

假设一个简单的场景，Alice 需要通过银行转给 Bob 一笔钱，使用之前的密码学知识就可以保证这个过程的安全可靠。

可以通过对称加密的方式，生成公私钥对，其中，公钥 a 可以公开，作为银行账户，私钥b作为账户密码，不予公开。

当 Alice 向 Bob 转 100 元时，可以在计算机中向银行发送这样一条请求<form:Alice,to:Bob, value:100>，表示Alice 向Bob转账100元。如果整个过程不加验证，被黑客发现这个漏洞后就可以不断地重复这个过程，直到把Alice的账户余额转空。

为了表示这个交易确实是由 Alice发出的，可以增加 Alice的签名，用Alice的公钥a所对应的私钥对这个请求签名。整个请求就成了{<form:Alice, to:Bob, value: 100>,signature:foo}，这样银行收到这笔交易后，就可以用Alice的公钥，也就是a对交易进行验证，判断是不是由Alice发出的。

但是由于 Alice 太过富有，转账成了{<form:Alice, to:Bob,value:1000000000.002>,signature: bar}，交易请求 <form:Alice,to:Bob,value：1000000000.002>体积太大，签名算法对大量数据的输入签名效率不高，这个时候，就可以采用消息摘要算法，减少计算签名输入的长度的工作量，如首先采用哈希算法计算Hash(<form:Alice,to:Bob, value:1000000000.002>)=baz，然后对摘要baz签名即可。当银行收到这笔交易时，同样先对交易计算哈希值，再验证签名即可。



Schnorr 签名的工作原理：https://blog.oleganza.com/post/162861219668/eli5-how-digital-signatures-actually-work

https://mp.weixin.qq.com/s?__biz=MzA5NzI4MzkyNA==&mid=2247483701&idx=1&sn=566750cfa2214e655efc37b31a7de131&scene=21#wechat_redirect

https://drive.google.com/drive/folders/1TWfqWHpEzBIUPzcwvqsGYyNQQ-If-ejI






传统的密钥共享方案依赖于一个中心化的可信机构来分发密钥。在这一过程中，密钥被分割成多个子密钥，分别发送给参与者。然而，这样的安排存在一个明显的弱点：可信中心可能成为攻击的目标，一旦受到破坏，系统的安全性就会受到严重威胁。

去中心化秘密共享方案应运而生，可以在没有可信中心的情况下安全有效地进行密钥共享。在这种方案中，子密钥的产生和分配由参与者共同协作完成，显著提高了整个系统的安全性。





### 去中心化秘密共享方案

自从密钥共享方案诞生以来，大量的不同环境下的密钥共享方案己经被提了出来。大部分的方案中都假设存在一个可信中心密钥分发者，负责将密钥分割成为子密钥，并且安全密钥的将子密钢发送给参与者。但是在实际环境中，可信中心往往是不存在的。所以一种新的无可信中心的密胡共享协议被提了出来以适应没有可信中心的环境。

在无可信中心的密钥共享中，子密朗的产生和分配都是由参与者本身合作完成的。在实际应用中，有可信中心的密朗共享可能存在可信中心的“权威欺骗”，并且在现实中需要成员具有较高的可信度也不是明智的假设。因此，和有可信中心的密钥共享相比，无可信中心的密钥共享安全性更高，实用性更强。

对无可信中心密钥共享研究的主要目的就是：寻找合适的方案来保证信息能够安全，有效地发布和传输。此外，无可信中心密明共享中的子密钥如何分发，是人们研究的热点问题，其发展空间还很大。因此，无可信中心密钥共享不仅存在着重要的理论价值，更在实际应用中存在着广泛的应用前景。目甜对于无可信中心的密明共享的应用主要集中在数字签名方面。对无可信中心的密明共享的加密研究并不多。下面是笔者个人提出的一种去中心化秘密共享方案。

去中心的化密钥共享方案实际上就是把密钥拆分成 n 份之后，对每一份秘密进行加密，然后将他们存储到区块链上去，这样可以解决密钥的分发存储。密钥发送到相应的节点后，该节点先对密钥做二次加密，签名，然后写到区块链上，当密钥恢复者需要恢复密钥时，它可以全网广播一条恢复密钥的信息，然后付给密钥段存储节点一定的 token ，密钥存储节点验证密钥并解密之后发送给恢复密钥的客户端。这样就可以达到去中心的秘密共享的目标。



https://learnblockchain.cn/article/1843



## (t, n) 门限的动态秘密共享方案

在 1979 年，Shamir 和 Blakley 分别提出了 (t, n) 门限秘密共享方案。这种方案允许一个秘密被分割成 n 个份额，只要收集到任意 t 个 (t≤n) 份额，就可以重构出原始的秘密。Shamir 的方案基于拉格朗日插值法，利用数学上的特性确保只有足够数量的子秘密才能解出原秘密。

动态秘密共享方案在此基础上进一步提高安全性，允许在不泄露原秘密的情况下，定期更新子秘密，使得攻击者即使获得了某一周期内的子秘密，也无法在下一周期中利用这些信息。





### （t，n）门限的动态秘密共享方案

1979 年 Shamir 和 Blakley 分别提出了一个（t，n）门限秘密共享方案，Shamir 的（t，n）门限方案是基于 Lagrange（拉格朗日）插值法来实现的，它通过构造一个 t-1 次多项式，并将需要共享的秘密作为该多项式的常数项，每个份额（子秘密）为满足该多项式的一个坐标点，由 Lagrange 插值定理可知，任意 t 个份额（子秘密）可以重构该多项式从而恢复秘密，而 t-1 个或更少的份额（子秘密）不能重构该多项式，因而得不到关于秘密的任何信息。

动态秘密共享体制的提出主要源于秘密共享方案的安全性问题。在（t，n）门限秘密共享方案中，方案的安全性是建立在攻击者不可能在秘密的生命周期内获取 t 个子秘密的前提之下的。然而实际上很难保证这一点，尤其是在秘密的生命周期较长的情况下，这一点就更难以保证。可验证秘密共享方案主要用来解决传统秘密共享方案中存在的分发者不诚实性问题和子秘密持有者的不诚实性问题，而面对敌手的破坏性攻击，可验证秘密共享方案并没有更好的安全性。

当然，对于周期上的安全性，可以通过不断更换秘密的办法得到解决，但是更换秘密并不总是可行的（比如说该秘密是一个重要文件或是一些军事、商业秘密等）。动态秘密共享方案通过在不改变秘密的情况下解决了秘密共享方案在周期上的安全性问题。动态秘密共享方案在保证秘密不变的情况下周期性地更换子秘密，从而使得每次更换子秘密时攻击者在前一个周期内所获得的信息完全失效。

这样一来，就可以根据可能受攻击程度的不同来相应地决定子秘密更换周期的长短，以保证在每一个周期内秘密的安全性。动态秘密共享还要保证过期的子秘密所包含的信息不会对未来秘密的构造产生不安全的影响。

#### 5.1 Amir Herzberg 方案

有关动态秘密共享的方案已有不少，Amir Herzberg 提出的方案是很经典的一个，方案是对 Shamir 的秘密共享方案实现动态化。

分发者 D 选择一个有限域 GF(q)（q 为大素数），为了方便说明，用 i 代替 Shamir 方案中的 xi的。在第 k 个时段，Pi 持有的子秘密用 si(k)(si 的 k 次方) 表示。

子秘密更新协议：每个时段开始时要进行子秘密更新，进入第 k 时段后，Pi 持有的子秘密要从 si(k-1) =f(k-1)（i）更新至 si(k) ，其中 f(k-1) (0) = s。整个过程如下：



更新后的子秘密显然符合门限秘密共享的要求，任意大于或等于 t 个参与者利用 Lagrange 插值法可恢复秘密。之后 Amir Herzberg 等人在他们的这篇文章中进一步提出了一个防止主动攻击的子秘密更新方案，并增加了可验证性，进一步加强了方案的安全性。

#### 5.2 Amir Herzberg 方案的改进

事实上 Amir Herzberg 的子秘密更新方案相当于 n 个参与者协商了一个常数项为零的 t-1 次多项式，事实上少于 n 个参与者也可以进行子秘密更新，步骤和原方案相同，如果参与子秘密更新的参与者少于门限值 t 时，可以对此方案进行改进，使它具有更好的灵活性和执行效率，方案描述如下： 



##### **5.2.1 AMIR HERZBERG 方案的改进分析**



这样 k（k<t）个参与者就实现了子秘密的更新，并且这个方案有很大的灵活性，在步骤（3）中，只需对 si′=si+χ·i ic 中 i 的次数进行修改，使次数大于 t-k 就可以提高门限值，如 si′=si+χ·iit-k+θ ，方案中的门限值就是 t+θ ，这相当于把储存秘密 s 的多项式变为 t+θ-1 次多项式。由于参与子秘密更新的成员只需选择一随机数，并进行简单的直和分解运算，与原方案相比执行效率很高。由于传递信息是通过安全信道，安全性可以得到保证。Amir Herzberg 的子秘密更新方案相当于 n 个参与者协商了一个常数项为零的 t-1 次多项式，给出参与子秘密更新的参与者少于门限值 t 也可以进行子秘密更新，并具有更好的灵活性和执行效率。进一步考虑，对于参与子秘密更新的人数大于或等于门限值时，即 k≥t 时，此方案仍可以更新子秘密，但是门限值却会发生变化，不太适合需要保持门限值不变的场合，没有 k<t 时方案更加灵活。











随着信息技术的发展，我们如何共享重要的信息和资料，同时保证其安全性，是一个非常重要的问题。秘密共享技术应运而生，它可以把一个秘密分割成多个 “ 子秘密 ” ，只有凑齐一定数量的子秘密才能重构原来的秘密。这为我们提供了一个分散风险的方式来保护重要信息。

早期的秘密共享方案大多需要一个可信的中心来生成和分发子秘密。但是实际应用中，可信中心不一定存在。因此，人们提出了去中心化的秘密共享方案。这类方案中，子秘密的产生和分配完全由参与者自己来完成，安全性更高。一种去中心化方案是将秘密分割加密后存储在区块链上，需要时参与者从区块链恢复自己的子秘密，最后重构原始秘密。这避免了中心节点的作用。



传统的秘密共享方案安全性依赖于攻击者无法获取足够数量的子秘密。但对于长周期秘密，这一假设可能不成立。因此，人们提出了动态秘密共享方案。它周期性更换子秘密，即使攻击者获取了过期的子秘密也无济于事。通过控制更换周期，可以应对不同威胁环境。

在子秘密重构阶段，参与者都会相互暴露自己的子秘密。这为攻击者提供了获取秘密的机会。因此，又设计了可安全重构的秘密共享方案，可以验证每个参与者子秘密的有效性，避免泄露真实秘密。

主动式秘密共享将时间划分不同阶段，每个阶段分配不同的秘密份额，以解决保存时间过长引发的安全问题。后续研究逐步完善了这一思路。



传统方案需要一个可信的中心来生成和分发子秘密。这不太符合分布式的需求。于是有人提出了无分发者秘密共享方案。

参与者联合生成一个随机秘密，然后自行生成子秘密。这避免了中心节点的作用。有的方案则需要参与者共享一个组公钥，联合解密才能获取秘密。还有方案引入了可验证的子秘密，防止参与者作弊。

无分发者秘密共享去除了传统模式中的可信分发者，参与者自主生成秘密份额。







门限签名中的 KeyGen 和 Sign 可看成是一种特殊的安全多方计算。

门限签名实现可分为：

* 基于 RSA 的门限签名机制
* 基于 ECDSA 的门限签名机制
* 基于 Schnorr 的门限签名机制
* 基于 BLS 的门限签名机制







去中心化、动态、可验证、主动更新、无分发者等都是秘密共享技术研究的前沿方向。这些技术在提高安全性的同时，也拓宽了应用场景，值得进一步研究。

我们就可以建立一个具有主动性、健壮性和可恢复性的分布式阈值秘密共享公钥密码系统的方法和系统。

主要思路是：

1. 初始化服务器，让它们形成密钥。

2. 同步服务器，使它们以离散的轮为单位操作。

3. 在每轮结束时计算更新后的密钥。这通过在通信网络上广播消息来实现。

4. 验证更新后的密钥以形成受损服务器的集合。

5. 恢复受损服务器。

关键特点是：

1. 主动性：通过周期性地重新分发和随机化秘密份额，限制攻击者获取秘密的速率。

2. 健壮性：诚实的服务器可以检测出故障服务器，服务不会中断。

3. 可恢复性：如果攻击者擦除它所损害的服务器上的所有本地信息，信息可以在服务器恢复正常协议后尽快恢复。

所以它是一个分布式的门限密码系统，在至少 (k+1) 个服务器正常和诚实的情况下可以维持服务，可以抵御攻击者同时获取 (k+1) 个服务器控制权的攻击,具有健壮性和可恢复性。

通过秘密分享、检测恢复和密钥更新三个模块的结合，最终构成了一个健壮的主动式秘密分享方案。该方案可以大大提高系统的安全性，使之可以抵御移动攻击者在多个时间段内逐步获取系统权限的持续渗透威胁。这类方案对于需要长期保存数据隐私和完整性的应用具有重要意义。















Threshold Signature Scheme (TSS) 是一种密码学原语，可用于分布式密钥生成和签名。在区块链客户端中使用 TSS 是一种新的范式，可以提供许多好处,特别是在安全性方面。从更广泛的意义上说，TSS 可以影响密钥管理系统的设计（例如加密钱包），并为DeFi用例提供本地支持。尽管如此，TSS仍然是一项新技术，所以也应考虑其风险和局限性。

在这篇文章中,我们将介绍什么是 TSS，它为区块链空间带来的潜在优势，如何在区块链客户端中实现它，它与 Shamir 密钥分享和多签方案的比较，以及使用 TSS 进行分布式密钥管理的不同方式。最后，我们将讨论风险和局限性。

为了理解 TSS，我们首先需要一些密码学的基本知识。自20世纪70年代以来，越来越多的互联网系统(如 TLS 和 PGP)采用了非对称密码学，也称为公钥密码学(PKC)。PKC 使用两把密钥：一个公钥和一个私钥。虽然公钥不是秘密，可以被公开和任何人使用，但私钥是代表系统安全的一段机密信息。

加密和数字签名是 PKC 的两大常见用途。加密和数字签名方案都依赖于三组算法。第一是公私钥对生成,第二是密文/签名的生成,第三是解密/验证过程。对于数字签名,签名算法需要私钥,它只被其所有者知晓,来产生一个唯一的签名。签名以一种方式附加到给定的消息上,使得任何持有公钥的人都能验证其真实性和正确性。

毫无疑问,区块链是一项非常强大的技术。它提供了一个共识层,用于组织和记录事件。这样一个基础设施为我们用户提供了建立去中心化经济甚至政府的潜力。令人惊讶的是,运行基本区块链所需的密码学可以仅仅基于数字签名。在区块链背景下,私钥代表身份,而签名是身份的公开声明或主张。区块链将按一定规则对语句进行排序和验证,以确保签名是不可伪造和正确的。

与区块链中使用的更经典的密码学相比,现代密码学工具箱包含一些很棒的魔术:零知识证明、同态加密和多方计算等。正如我们在过去十年看到的那样,区块链研究极大地推动了应用密码学,最近在所有这些领域都取得了突破。

在本文中,我们将关注其中一个这样的突破:高效安全阈值签名(TSS)。

多方计算(MPC)是密码学的一个分支,起源于安德鲁·Yao的开创性工作,将近40年前。在MPC中,一组不相互信任的参与方试图共同计算他们输入的函数,同时保密这些输入。

举个例子,假设一个公司的n名员工想知道谁的工资最高,但不向彼此透露实际工资。这里私人输入是工资,输出将是收入最高的员工姓名。使用MPC进行此计算,我们可以得出在整个计算过程中甚至没有透露一个工资。 MPC的两个主要特性是正确性和隐私性:

正确性:算法产生的输出是正确的(如预期的那样)。

隐私性:参与方持有的秘密输入数据不会泄露给其他参与方。

我们将使用MPC以分布式方式计算数字签名。让我们看看上述属性如何应用于签名。回想一下,对于签名,我们有三个步骤:

密钥生成:第一步也是最复杂的一步。我们需要生成一个公钥,它将用于验证未来的签名。但我们还需要为每个参与方生成一个单独的秘密,我们将其称为秘密份额。在正确性和隐私方面,我们说该函数将为所有参与方输出相同的公钥,并为每个参与方输出不同的秘密份额,以便:(1)隐私性:秘密份额数据不会在参与方之间泄露,和(2)正确性:公钥是秘密份额的函数。

签名:这一步涉及签名生成函数。每个参与方的输入将是在前一步(分布式密钥生成)中创建的其秘密份额。还有一个为所有参与方所知的公共输入,即要签名的消息。输出将是一个数字签名,隐私属性确保计算过程中没有泄露秘密份额。

验证:验证算法与经典设置中的算法相同。为了与单密钥签名兼容,拥有公钥知识的每个人都应能验证和验证签名。这正是区块链验证节点所做的。

我们称将分布式密钥生成(DKG)与分布式签名组合起来的方案为阈值签名方案(TSS)。

TSS 可自然地用于区块链中,方法是改变区块链客户端以使用 TSS 生成密钥和签名。这里,我们使用区块链客户端一词是指完整节点执行的命令集。实际上,TSS 技术允许我们用分布式计算替换所有与私钥相关的命令。

为了更详细地解释,我们简要描述一下在经典区块链设计中如何创建新的地址。简单来说,我们可以通过生成私钥,然后从私钥计算公钥来创建新地址。最后,区块链地址从公钥派生出来。

现在,使用 TSS,我们将有 n 个参与方共同计算公钥,每个参与方持有私钥的一个秘密份额(单独的份额不会透露给其他参与方)。我们可以用与传统系统相同的方式从公钥派生地址,使区块链对地址的生成方式无知。优点是私钥不再是单点故障,因为每个参与方只持有其中一部分。

对交易进行签名时也可以做同样的操作。在这种情况下,不是单个参与方用其私钥签名,而是在多个参与方之间运行分布式签名生成。因此,只要足够多的参与方行事诚实,每个参与方都可以产生有效签名。同样,我们从本地计算(单点故障)转向了交互计算。

重要的是要提到，分布式密钥生成可以以一种允许不同类型的访问结构的方式完成:一般的“t 个中的 n 个”设置将能够承受高达 t 个任意故障的私钥相关操作,而不会危及安全性。

TSS 与多签之间的主要区别在于，多签是区块链特定的,需要为每个区块链重新实现,在某些情况下,可能根本不支持。相反,TSS 完全依赖密码学,所以支持总是可能的。这里有一篇很好的文章，用图示说明了两者之间的区别。

TSS 与 Shamir 密钥分享方案的另一个区别在于，在 TSS 中，在其整个生命周期中,私钥从未出现在单一位置。

基于 TSS 的钱包与传统加密货币钱包有所不同。通常,传统钱包会生成一个种子短语,并使用它确定性地派生地址。用户可以稍后使用这种分层确定性(HD)结构来获取与钱包地址对应的私钥并对交易进行签名，以及使用种子短语恢复所有钱包密钥。

在阈值钱包中，事情更复杂。尽管可以生成 HD 结构，但其生成必须以分布式方式计算，作为另一个 MPC 协议。在 TSS 中，参与方需要共同决定使用下一个密钥。换句话说，每个参与方都会有自己的种子短语。种子短语是分别生成的，永远不会合并，所以单独的一方无法从其种子推导出私钥。

基于 TSS 的钱包还有一个很好的安全功能，即启用私钥轮换而不改变对应的公钥和区块链地址。私钥轮换，也称为主动密钥分享，是另一个 MPC 协议，它以密钥份额为输入，并输出一组新的密钥份额。旧的密钥份额可以被删除，新的份额可以以相同的方式使用。

这样的结构为安全性添加了时间维度，这意味着攻击者必须同时处于多个位置才能攻击阈值钱包。在轮换之前和之后组合密钥份额对攻击者而言没有任何额外好处，如果他们想伪造签名的话。

这种类型钱包的一个缺点是缺乏种子短语使其与单密钥钱包系统不兼容。因此，选择谁持有密钥份额非常重要。

有几种可能的架构：

外包 TSS：用户将让 “ n ” 个服务器代表他们运行计算。有效地将密钥生成、管理和签名外包给服务提供商,他们不是资产的所有者,但提供一定的安全层面以换取一些激励。

使用多个设备：用户将在他们拥有的设备之间运行 TSS。例如,一方将是某些 IoT 设备，另一方将是用户的手机,还有一方是他们的笔记本电脑，等等。

混合：TSS 将运行一些由外部服务提供商控制的参与方,同时一些参与方运行在用户拥有的设备上。

第一种方法将复杂的 TSS 计算负载转移出用户客户端。另一方面，服务提供商可能会勾结（我们假设在同一时间不会被攻击足够多的提供商，但在实践中，他们可能会）并窃取用户的资产。

第二种方法给用户充分的控制权，但进行交易很麻烦，因为需要多个设备联机并参与 TSS 计算。

第三种选择被认为是两全其美的，因为它为用户提供了轻松快捷的交易方式，而无需放弃在没有用户授权的情况下进行交易。

多年来，研究人员已经找到了许多数字签名的用途，其中一些出人意料的非常微妙。正如上面所述，TSS 是一种密码学原语,可以极大地提高安全性。在区块链方面，我们可以说许多功能性可以被基于 TSS 的密码学所取代。去中心化应用、第 2 层扩展解决方案、原子交换、混合、继承等都可以建立在 TSS 框架之上。这最终将允许使用更便宜、更可靠的替代方案取代昂贵和风险较大的智能合约操作。

举几个具体的例子：Multi-Hop Locks 巧妙地使用两方签名，可以作为比特币闪电网络更安全、更私密的支付通道网络的替代方案。ShareLock 可能是以太坊上基于验证单个阈值签名的最便宜的链上混合解决方案。

尽管 TSS 有巨大的潜力改变我们使用区块链的方式，作为一项相对较新的技术，它仍然存在一些局限性和问题。与经典公钥加密相比，TSS 协议可以非常复杂，且尚未经过 “ 实战测试 ” 。通常，TSS 需要比简单数字签名更弱的额外密码假设。结果是出现了传统设置中不存在的密码攻击向量。

总之，TSS 是一种迷人的密码原语,有可能显着改变我们使用区块链的方式。它为区块链空间带来安全性方面的好处，但作为一项新技术，其风险和局限性也应该考虑在内。







【密码学08｜分布式密码学】 https://www.bilibili.com/video/BV1484y1K78q







很多密码学应用要求一个可信的权威持有秘钥。这种系统存在单点故障和秘钥托管的问题。分布式秘钥产生 DKG（distributed key generation）通过多方参与，计算共享的公钥与私钥集，解决上述问题， 分布式秘钥产生不依赖任何可信的第三方。在 (n,t)-DKG 中， n 为节点数量，t 为阈值， DKG协议允许 n 个节点共同产生秘钥，使得任何数量大于阈值t的节点子集都能使用该共享秘钥，然而任何数量少于阈值 t 的节点子集都没有对该共享秘钥的任何知识。

可验证秘密共享

可验证秘钥共享 (verifiable secret sharing， 简称 VSS) 是 DKG 的基本构造块，VSS 的概念被 Shamir 和 Blakley 引入。

(n,t+δ, t) -秘密共享：对整数 n, t ,δ 满足 n>=t+δ>t>=0 ，一个(n,t+δ, t) 秘密共享协议是被用于一个交易方（dealer） 在 n 个节点之间共享一个秘钥，使得其中任何 t+δ 或者更多的节点能够计算密钥s, 但是t个或更少的节点没有关于s的任何信息。

δ=1 的秘密共享被称之为阈值秘密共享(threshold secret sharing) ，记为（n,t)-秘密共享。

在一些秘密共享应用中，客户端需要验证持续的交易（deal）来避免交易方（dealer）的恶意行为。一种拥有这种可验证性保证的模式被称之为可验证秘密共享（verifiable secret sharing) VSS 。

一个可验证秘密共享 (n,t)-VSS 模式有两个阶段（phase）组成。共享阶段和重建阶段





请作为老师，用尽可能通俗易懂的、口语化的方式给不了解它的人详细讲解以下内容，可以用比喻、类比的手法解释难懂的概念，如果能达到让一个高中生听懂的地步就很好了：



好的,我来用简单的语言为你解释配对(pairing)在密码学中的作用和应用。

首先,配对就是一个数学函数,它把两个不同的椭圆曲线群映射到一个目标群。举个简单比喻,配对就像一个翻译官,可以把两国人民的语言翻译到一种“通用语言”。

配对有两个很酷的性质:

1. 双线性 - 如果我们把群元素进行某种运算,配对的结果也相应地运算。就像翻译官可以准确翻译语言中的加减乘除运算。
2. 非退化 - 配对不会把所有内容都翻译成一样,不同元素的配对结果也不同。

有了配对,我们可以设计出很多高效的密码算法:

1. 三方迪菲-赫尔曼密钥交换,让三方都可以商定一个密钥,之前只有两方可以。
2. BLS签名,使签名非常短小,也可以进行多签名聚合。
3. 基于身份的加密,使用邮箱作为公钥,不需要记忆或传递公钥。
4. 零知识证明,可以证明知道某事,但不泄露事情详情。

配对的计算需要两步,第一步类似翻译过程,第二步类似提升翻译结果的准确度。具体数学细节比较复杂,但使用配对可以像调用API函数一样,不需要了解内部细节。

总之,配对是一种超强大的密码学工具,使许多运算变得容易和高效。我尽量用通俗的语言和日常生活的类比解释清楚它的主要思想,具体数学证明等细节此处不展开。如果例子还不太明白,请提出来,我会继续细致解释。



现在请进一步解释，不用太通俗易懂。但是要专业、具体、详细：



好的,我来尽可能专业和详细地解释配对在密码学中的概念和应用:

1. 配对的定义

配对是定义在三个具有相同阶p的环G1,G2和GT上的双线性映射e: G1 x G2 → GT。其中G1,G2的生成元分别是g1和g2,GT的生成元是gT。当G1=G2时,称为对称配对;否则为非对称配对。

1. 配对的两个关键性质

(1) 双线性:对所有u∈G1,v∈G2,a,b∈Zp,有e(ua,vb)=e(u,v)ab。这保证了运算符可以从G1和G2移入GT中。

(2) 非退化:e(g1,g2)≠1GT。这排除了恒等映射的无意义情况。

1. 配对的计算

配对运算包括两步:米勒循环计算基底值fp,u(v),最后一次求幂运算(fp,u(v))^(qk-1)/p。米勒循环复杂度较低。

1. 配对在密码学中的应用

(1) 三方Diffie-Hellman密钥交换协议

(2) BLS短签名方案,支持签名聚合

(3) 基于身份的加密方案

(4) 零知识证明方案

1. 实现配对加速的方法

使用非对称配对;利用多重指数运算进行批处理;优化G1和G2的使用等。

综上所述,配对作为一种特殊的双线性映射,其双线性和非退化性使其在构建高效密码方案中发挥巨大作用。我尽量用专业的方式全面系统地概述了配对的相关知识,请您指出还需要补充解释的部分。





请按照原意翻译



配对或双线性映射 2022年12月31日

摘要:配对,或双线性映射,是密码学中一个非常强大的数学工具。配对为我们提供了最简洁的零知识证明1,2,3,最高效的阈值签名4,第一个可用的基于身份的加密(IBE)方案5,以及许多其他高效的密码系统6。在这篇文章中,我将教你一点关于配对性质、密码应用和迷人历史的知识。事实上,读完这篇文章后,你们中的一些人可能会想待一两年的监狱。

推特更正:最初宣布这篇博文的推文声称“SNARKs不可能没有[配对]”,其中高亮显示的S意味着这种SNARKs的“简洁性”。然而,感谢推特上的几位朋友,我意识到这不完全正确,取决于人们对“简洁”的理解。具体来说,在Gentry和Wichs7定义的对数意义上的“简洁”SNARKs,可以从各种假设得出,包括离散对数8或随机谕示9。此外,在O(1)组元素证明大小意义上的“简洁”SNARKs,也可以从RSA假设得出10。目前,配对为我们提供的是具有最小具体证明大小(即字节数)的SNARKs。

初步知识 你熟悉具有素阶的循环群(例如椭圆曲线) 设1GT为群GT的幺元 设x←RS表示从集合S中随机采样元素x 回忆⟨g⟩=G表示g是群G的生成元 配对的定义 配对,也称为双线性映射,是一个函数e:G1×G2→GT,定义在三个具有素阶p的群G1,G2和GT上,其生成元分别是g1=⟨G1⟩,g2=⟨G2⟩和gT=⟨GT⟩。

当G1=G2时,称配对为对称的。否则,它是非对称的。

最重要的是,配对对密码学有两个有用的性质:双线性和非退化。

双线性 双线性要求对所有u∈G1,v∈G2,和a,b∈Zp:

e(ua,vb)=e(u,v)ab(2)

对密码学目的来说,这是最酷的性质。例如,这使得三方迪菲-赫尔曼密钥交换等有用的应用成为可能。

非退化 非退化要求:

e(g1,g2)≠1GT(3)

为什么需要这个性质?我们需要非退化,因为如果没有非退化,很容易(也很无用)定义一个(退化的)双线性映射,对所有输入都返回1GT。这样的映射将满足双线性,但完全无用。

效率 效率要求存在一个多项式时间的算法,以组元素的大小(即λ=log2p)为参数,可以用于计算配对e的任何输入。

为什么需要这个要求?它排除了平淡无奇但计算上不可行的配对。(点击展开。)

历史 这是我对配对的有限历史理解,主要来自Dan Boneh在这个视频中的叙述,以及我对相关文献的研究。如果你知道更多历史,请给我发邮件,我会试着加入。

一个数学家在监狱中 (密码)配对的历史始于一位名叫André Weil11的数学家,二战期间他因拒绝服兵役被送入法国军队的监狱。在那里,Weil“设法说服那位思想开明的监狱主任,允许[他]拥有一个单人牢房,可以保留[..]一支笔,墨水和纸。”

Weil利用新获得的工具,在两个椭圆曲线群之间定义了一个配对。然而,在那个时候非常奇怪的是,Weil下了很大功夫来确保他定义的配对是可计算的。正是这额外的努力使今天基于配对的密码学成为可能。12

去监狱,不去大学? 有趣的是,Weil在监狱中的时间是如此富有成效,以至于他开始怀疑是否应该每年在那里呆几个月。更妙的是,Weil考虑是否应该向有关部门建议每个数学家都应该在监狱中呆一段时间。Weil写道:

我开始认为,对抽象科学来说,没什么比监狱更有益的了。

[...]

我的数学工作进展远远超出了我最狂野的想象,我甚至有点担心——如果只有在监狱里我才能工作得这么好,那我是不是每年都得安排呆两三个月的牢房?

与此同时,我正考虑给相关部门写一份报告,大致如下:“致科学研究主任:最近通过个人经历,我有机会发现监狱系统机构的待遇对纯粹的、无私的研究有相当大的好处,特此报告,等等。”

你可以在他迷人的自传中读到这一切,这本自传是从他作为一位数学家的视角写的。13

从破译密码学到建立密码学 Weil的工作奠定了基础。但是还需要三个发展,配对密码学才能兴起。

第一步发展:Miller算法 1985年,Victor Miller写了一篇手稿,展示了Weil配对(实际上涉及求幂指数级多项式)可以高效地在多项式时间内计算。14

1984年12月,Miller在IBM关于椭圆曲线密码学的演讲中声称,椭圆曲线离散对数难以计算,难于有限域上的普通离散对数。15 Miller受到听众Manuel Blum的挑战,用还原论证支持这个说法:即展示一个求解椭圆曲线离散对数的算法B可以高效地转化成另一个算法A,用于求解有限域中的离散对数。这样的还原将意味着B解决的问题(即计算椭圆曲线离散对数)至少与A的问题(即计算有限域离散对数)一样困难,如果不是更困难的话。

Miller试图通过考虑椭圆曲线群和有限域之间唯一的关联——Weil配对,来找到一个还原。有趣的是,他很快意识到,虽然Weil配对给出了一个还原,但它是朝相反方向的:即一个求解有限域离散对数的算法A可以在Weil配对的帮助下,高效地转化成一个求解椭圆曲线离散对数的算法B。这个“不需要的”还原很容易看出来。由于e(ga,g)=e(g,g)a,求解椭圆曲线元素ga∈G的离散对数,只需要求e(g,g)a∈GT的离散对数,后者实际上是一个有限域的乘法子群(参见配对的内部细节)。

这几乎表明Miller想证明的相反结论,可能会破坏椭圆曲线密码学。但幸运的是,Weil配对映射到的扩域的度数太大,使这个“不需要的”还原变得低效,因此并不能构成还原。

这整个事件使Miller对研究Weil配对是否可以有效计算起了兴趣,这导致了他的算法发现。有趣的是,他将这篇手稿提交给了FOCS,一个顶级理论计算机科学会议,但论文被拒绝,要到很久后才在密码学杂志(根据Miller的说法)发表。16

第二步发展:MOV攻击 1991年,Menezes、Vanstone和Okamoto17利用Miller计算Weil配对的有效算法,打破某些椭圆曲线上的离散对数假设,时间复杂度为亚指数级。这相当惊人,因为在那时对椭圆曲线还没有已知亚指数级时间的算法。

他们的攻击,称为MOV攻击,使用配对将椭圆曲线离散对数挑战ga∈G映射到目标群体为e(ga,g)=e(g,g)a∈GT。由于目标群是有限域Fkq的子群,这允许使用更快的亚指数时间算法来计算e(g,g)a上的离散对数。

第三步发展:Joux的三方Diffie-Hellman 到目前为止,配对似乎只对密码分析有用。没有人知道如何使用它们来建立(而不是攻击)密码学。

这在2000年发生了改变,当时Joux18使用配对实现了一种在三方之间的一轮密钥交换协议,或三方Diffie-Hellman。在此之前,这种一轮协议只在两方之间已知,而三方需要两轮。

从那时起,大量新的高效密码学涌现:

BLS(短)签名4 基于身份的加密5 可加性同态加密,支持一次乘法运算19
 简洁的零知识证明1

这里可以注意到一个有趣的模式,配对如何从一个用于攻击密码系统的密码分析工具,发展成一个用于建立密码系统的构造工具。有趣的是,在格密码学的发展中也出现了相同的模式。

配对运算的算数技巧 在密码学家证明密码系统的正确性或安全性时,他们经常使用一些与配对相关的技巧。

最明显的技巧“指数相乘”来自双线性特性。

e(ua,vb)=e(u,v)ab(9)

双线性也意味着以下技巧: e(u,vb)=e(u,v)b(10)

或者,另一种表达: e(ua,v)=e(u,v)a(11)

另一个技巧,也是定义双线性的等价方式: e(u,v⋅w)=e(u,v)⋅e(u,w)(12)

为什么行得通?设v和w相对于g2的离散对数分别为y,z。则: e(u,v⋅w)=e(u,gy2⋅gz2)=e(u,gy+z2)=e(u,g2)y+z=e(u,g2)y⋅e(u,g2)z=e(u,gy2)⋅e(u,gz2)=e(u,v)⋅e(u,w)(13)(14)(15)(16)(17)(18)

或者,另一种表达: e(u,v/w)=e(u,v)e(u,w)(19)

配对的应用 三方Diffie-Hellman 这个协议由Joux在2000年提出18,假设配对是对称的:即G1=G2=⟨g⟩=defG。

有三方Alice、Bob和Charles,密钥分别为a,b,c。他们互相发送公钥ga,gb,gc,并约定共享密钥k=e(g,g)abc。20

如何做到?

考虑Alice的视角。她从Bob和Charles获得gb和gc。首先,她可以用自己的密钥a计算gab。其次,她可以用配对计算e(gab,gc)= e(g,g)abc=k。

由对称性,其他参与方也可以做同样的计算,并认同相同的k。

这个协议也可以推广到非对称配对,其中G1≠G2。

BLS签名 Boneh、Lynn和Shacham基于配对提出了一种非常短的签名方案4,具体如下:

假设G2=⟨g2⟩且存在随机谕示函数H:{0,1}∗→G1。 密钥s∈Zp,公钥pk=gs2∈G2。 签名消息m时,计算σ=H(m)s∈G1。
 验证签名σ与消息m匹配公钥pk,检查e(σ,g2)=?e(H(m),pk) 可以看出,正确计算的签名通过验证,因为: e(σ,g2)=?e(H(m),pk)⇔e(H(m)s,g2)=?e(H(m),gs2)⇔e(H(m),g2)s=?e(H(m),g2)s⇔e(H(m),g2)=e(H(m),g2)(20)(21)(22)(23)

参见BLS论文4关于安全性证明。

BLS签名的酷属性 BLS签名非常惊人:

给椭圆曲线库,实现很简单 可以聚合在同一消息m上的不同公钥的多个签名为一个多签名,只需2次配对验证 甚至可以聚合不同消息的签名为单个聚合签名 但这需要n+1次配对验证 可以轻松有效构建BLS门限签名方案,t出n个签名者可协作签名,但少于t不能生成有效签名 更好的是,BLS门限签名确定性,对应门限可验证随机函数,可用于链上生成随机性 可以定义BLS签名的高效盲化变体,签名方可以在不知晓消息m的情况下对其签名 BLS签名在实践中非常高效 就我记得,它们是最高效的(1)多签名,(2)聚合签名和(3)门限签名方案 对单签名者BLS,比非配对友好曲线上的Schnorr签名慢 如果你对这些签名概念感到困惑,可以看我的幻灯片。

基于身份的加密(IBE) 在IBE方案中,可以直接对友好的电子邮件地址(或电话号码)加密,而不需要记忆或正确输入笨拙的公钥。

Boneh和Franklin基于配对给出一个非常高效的IBE方案。5

对于IBE来说,需要引入一个可信任的第三方(TTP)称为私钥生成中心(PKG),根据用户的邮件地址为他们生成密钥。这个PKG拥有一个主密钥(MSK)msk∈Zp,对应一个主公钥(MPK)mpk=gs2,其中⟨g2⟩=G2。

mpk对外公开,可以用来针对给定邮件地址的用户加密消息。关键是,PKG必须保密msk。否则,获取它的攻击者可以导出任意用户的密钥并解密所有消息。

可以看出,PKG是一个单点故障:msk被盗就危及所有用户的保密性。为降低风险,可以将PKG分散到多个机构,需要达到门限数目的机构被入侵才能盗取msk。

设H1:{0,1}∗→G∗1和HT:GT→{0,1}n为两个模型化为随机预言机的哈希函数。要向ID为id的用户加密一个n比特消息m,可以计算:

gidrc=e(H1(id),mpk)∈GT←RZp=(gr2,m⊕HT((gid)r))∈G2×{0,1}n

为了解密,ID为id的用户必须先从PKG获取其解密密钥dskid。我们假设PKG有方法认证用户身份,然后再发给他们密钥。例如可以通过邮件实现。

PKG计算用户的解密密钥:

dskid=H1(id)s∈G1

用户拿到解密密钥后,可以对密文c=(u,v)进行解密:

m=v⊕HT(e(dskid,u))

你可以看出,正确加密的密文可以被成功解密,因为:

m=v⊕HT(e(dskid,u)) =(m⊕HT((gid)r))⊕HT(e(H1(id)s,gr2)) =(m⊕HT(e(H1(id),mpk)r))⊕HT(e(H1(id),g2)rs) =m⊕(HT(e(H1(id),gs2)r)⊕HT(e(H1(id),g2)rs)) =m⊕(HT(e(H1(id),g2)rs)⊕HT(e(H1(id),g2)rs)) =m

关于这个方案在选择明文攻击下的安全性证明,请参考原论文。

配对是如何工作的?我大多数情况下并不清楚。为什么?因为我从未真正需要知道这一点。这也正是配对的美妙之处:可以将其作为一个黑盒使用,对内部一无所知。

尽管如此,让我们还是稍微描绘一下这个黑盒的内部。我们考虑流行的BLS12-381配对友好曲线,这是Barreto、Lynn和Scott提出的BLS曲线族的一员。

关于BLS12-381,参与配对的三个群组G1,G2,GT如下:

G1是椭圆曲线E(Fq)={(x,y)∈(Fq)2 | y2=x3+4}的一个子群,其中|G1|=p

G2是另一个椭圆曲线E′(Fq2)={(x,y)∈(Fq2)2 | y2=x3+4(1+i)} 的一个子群,其中i是-1的平方根,|G2|=p。

GT是所有Fqk中的p次根,其中k=12称为嵌入度。

配对映射e(⋅,⋅)如何跨这三个群工作?其展开形式类似:

e(u,v)=fp,u(v)(qk−1)/p

这里要知道计算配对包含两步:

1. 计算基fp,u(v),也称为米勒循环
2. 将这个基提升到固定指数(qk−1)/p,也称为最终指数法

这一步比第一步耗时更多

想进一步了解内部工作原理,可参考其他资料。

实现基于配对的密码学

这一节讨论实践者可以利用的各种实现层面的细节,以加速他们的配对实现。

使用不对称配对!

BLS12-381配对是不对称的:即G1≠G2是两个不同的群(同阶)。但是也存在对称配对,其中G1=G2是同一个群。

不幸的是,这样的对称配对只存在于特殊的超奇异曲线上,这大大限制了基础效率或安全性。也就是说,在相同安全级别下,这种超奇异曲线不如不对称配对使用的曲线高效。

因此,现今密码实践者,就我所知,完全依赖不对称配对,因为在相同安全级别下它们更高效。

BLS12-381性能

下面给出Filecoin实现中BLS12-381曲线的一些关键性能数据(使用Rust blstrs库封装了流行的blst库)。这些微基准测试在10核2021 Apple M1 Max上用cargo bench运行获得。

配对计算时间:

米勒循环计算需210微秒

最终指数法需276微秒

所以整个配对大约需486微秒。

指数运算时间:

G1指数运算最快,需72微秒

G2指数运算约为其2倍,需136微秒

GT指数运算比G2慢约3.5倍,需500微秒

注意:这些基准测试中,指数运算的底是随机选取的,没有对其进行预计算,否则可以使这些时间提速2-4倍。

多指数运算:这是一种众所周知的优化,我在此简要提及。具体来说,许多库可以比逐一计算k个指数运算并聚合其积快很多地计算积∏0<i<k(gi)xi。

例如,blstrs在这方面似乎非常快:

在G1中的大小为256的多指数运算总共只需760微秒,即每个指数运算只需3微秒!如果普通计算需要总共18.5毫秒,慢了24倍。

在G2中的大小为256的多指数运算总共只需1.88毫秒,即每个指数运算只需7.33微秒!如果普通计算需要总共35.3毫秒,慢了18.8倍。

群元素大小:

G1群元素最小,例如BLS12-381上为48字节,BN254曲线上为32字节

G2群元素为其2倍大,例如BLS12-381上为96字节

GT元素为其12倍大。一般来说,对于嵌入度为k的配对友好曲线,元素大小为k倍。

其他操作时间:

G1乘法(注意我们使用乘法表示法而不是加法表示法):

普通乘法:565纳秒(两点均在射影(X,Y)坐标下)

混合乘法:438纳秒(第一点在射影坐标,第二点在仿射(X,Y,Z)坐标下)

更快,因为节省了一个射影到仿射转换

G2乘法:

普通乘法:1,484纳秒

混合乘法:1,095纳秒

散列到G1大约需50微秒(不考虑额外的通过SHA2-256散列更大消息的时间)

在G1和G2间转换:

设计基于配对的密码方案时,要仔细考虑使用G1还是G2。

例如,在BLS签名中,如果要获得较小签名,可以计算签名σ=H(m)s∈G1,并接受稍大一些的公钥be在G2中。另一方面,如果要最小化公钥大小,可以让公钥在G1中,同时承受稍长的G2签名计算时间。

G1和G2的使用还会受到其他因素影响,例如存在同构φ:G2→G1,或散列到这些群的能力等。事实上,这种同构的存在将配对分为两种类型:2型和3型(更多信息见Galbraith等人的文献)。

与非配对友好椭圆曲线比较:

与不可配对的椭圆曲线群相比,配对友好椭圆曲线大约慢2倍。

例如,流行的素阶椭圆曲线群Ristretto255提供:

≈2倍快的40微秒指数运算

使用预计算可以使其加速到10微秒,当指数运算的底固定时

32字节群元素大小

多重配对:

回忆计算一个配对的实际工作原理(见公式34),你会注意到以下优化:

当需要计算n个配对的积时,可以先计算n个米勒循环,然后进行1次最终指数法,而不是进行n次。这大大减少了许多应用中的配对计算时间。

即:∏ie(ui,vi)=∏i(fp,ui(vi)(qk−1)/p)=(∏ifp,ui(vi))(qk−1)/p

总结:

本博客文章本打算只对配对的三个性质:双线性、非退化和高效计算做一个简短概述。

不幸的是,我无法抑制对它们迷人历史的阐述。同样,我也无法让你在没有见识几个配对强大密码应用的情况下就离开。

之后,我意识到实现配对密码系统的从业者可能会从略知一二它们的内部工作原理中受益,因为这些细节可以用来优化实现。
