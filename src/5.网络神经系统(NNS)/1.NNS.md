https://www.reddit.com/r/dfinity/comments/o4zdy6/we_are_david_johan_nicolas_and_ryan_ask_us

---

https://medium.com/dfinity/understanding-the-internet-computers-network-nervous-system-neurons-and-icp-utility-tokens-730dab65cae8

https://medium.com/dfinity/getting-started-on-the-internet-computers-network-nervous-system-app-wallet-61ecf111ea11

https://allthingsinternetcomputer.substack.com/p/how-you-can-earn-icp-through-the

https://icpleague.com/thread/517

https://internetcomputer.org/how-it-works/network-nervous-system-nns/

https://medium.com/dfinity/the-dfinity-blockchain-nervous-system-a5dd1783288e

https://medium.com/dfinity/future-governance-integrating-traditional-ai-technology-into-the-blockchain-nervous-system-825ababf9d9

https://dominic-w.medium.com/part-i-of-daos-new-horizons-and-challenges-in-depth-653c79c5ef5

https://wiki.internetcomputer.org/wiki/Limitless_Scaling

https://wiki.internetcomputer.org/wiki/New_Subnet_Creation

https://tingfei.space/posts/nns_summary/

https://www.cnblogs.com/helios-fz/p/15547991.html

https://wiki.internetcomputer.org/wiki/Network_Nervous_System

https://zhuanlan.zhihu.com/p/404721913

https://zhuanlan.zhihu.com/p/378362565

---

https://dashboard.internetcomputer.org/sns

https://dashboard.internetcomputer.org/neurons

sns1ï¼šhttps://sqbzf-5aaaa-aaaam-aavya-cai.ic0.app

https://internetcomputer.org/docs/current/developer-docs/integrations/sns

https://internetcomputer.org/sns

https://medium.com/dfinity/how-the-service-nervous-system-sns-will-bring-tokenized-governance-to-on-chain-dapps-b74fb8364a5c

https://www.youtube.com/watch?v=nZBWx6y070Y

https://wiki.internetcomputer.org/wiki/Service_Nervous_System_(SNS)

https://internetcomputer.org/sns/faq

https://wiki.internetcomputer.org/wiki/Proof_of_Personhood#Personhood_Score

https://wiki.internetcomputer.org/wiki/New_Subnet_Creation



## NNSæ˜¯å¹²å˜›çš„

æ­£å¦‚åœ¨å‰é¢æ€»ç»“é“¾é’¥å¯†ç å­¦æ—¶æ‰€è¯´ï¼š

***IC æœ€ä¼Ÿå¤§çš„åˆ›æ–°åœ¨äºï¼šé€šè¿‡ä¸€ç³»åˆ—å¤æ‚çš„å¯†ç å­¦æŠ€æœ¯ï¼Œå®ç°äº†å­ç½‘å†…éƒ¨è‡ªå·±è¾¾æˆå…±è¯†ï¼Œå¯ä»¥ç†è§£ä¸ºä¸€ç§åˆ†ç‰‡æŠ€æœ¯ã€‚æœ‰äº†é“¾é’¥å¯†ç å­¦æŠ€æœ¯ï¼Œå­ç½‘ä¹‹é—´å¯ä»¥è¿›è¡Œå®‰å…¨çš„è·¨å­ç½‘é€šä¿¡ã€‚å› ä¸ºä¸éœ€è¦æ•´ä¸ªç½‘ç»œçš„å…¨å±€å…±è¯†ï¼ŒIC å¯ä»¥é€šè¿‡æ·»åŠ æ›´å¤šå­ç½‘æ¥å®ç°æ¨ªå‘æ‰©å±•ã€‚***



ä»æŠ€æœ¯æ¶æ„ä¸Šæ¥è®²ï¼ŒIC å¯ä»¥æ— é™æ‰©å®¹ã€‚åªè¦éœ€è¦ï¼Œå°±å¯ä»¥ä¸æ–­æ·»åŠ æ–°å­ç½‘è¿›æ¥ã€‚ä½†æ˜¯å¯¹äºå•ä¸ªå­ç½‘æ¥è¯´ï¼Œåœ¨å­ç½‘å†…éƒ¨è¿›è¡Œå…±è¯†çš„æ—¶å€™ï¼Œæˆå‘˜æ˜¯å›ºå®šçš„ï¼Œå› ä¸º BLS é˜ˆå€¼ç­¾åçš„ç§é’¥ç‰‡æ®µå·²ç»æå‰åˆ†å‘ç»™å…±è¯†å§”å‘˜ä¼šçš„æˆå‘˜äº†ã€‚å°±ç®—æœ‰æ–°å‰¯æœ¬è¦åŠ å…¥å­ç½‘ä¹Ÿå¾—å…ˆ â€œ å¾…å‘½ â€ ï¼Œç­‰ä¸‹ä¸ªæ—¶æœŸå¼€å§‹æ—¶å†åˆ†äº«ç§é’¥ç‰‡æ®µã€‚æ‰€ä»¥å¯¹äºå•ä¸ªå­ç½‘æ¥è¯´ï¼Œæˆå‘˜éœ€è¦ä¿æŒç›¸å¯¹ç¨³å®šï¼Œä¸èƒ½åƒæ¯”ç‰¹å¸é‚£æ ·èƒ½éšæ—¶éšåœ°åŠ å…¥æŒ–çŸ¿ã€‚

å¦å¤–ï¼ŒIC èƒ½ä¸æ–­åˆ›é€ å­ç½‘ï¼ˆåˆ†ç‰‡ï¼‰ï¼Œè¿™å°±éœ€è¦ä¸€ä¸ªåœ°æ–¹ç»Ÿè®¡è¿™äº›å­ç½‘ï¼Œä¸ç„¶åäººä¹Ÿç»„å»ºä¸€ä¸ªå­ç½‘å†’å…… IC çš„å­ç½‘å°±ä¸å¥½äº†ã€‚å¦‚æœå¯ä»¥éšæ„åˆ›å»ºå­ç½‘ï¼Œé‚£ä¹ˆå­ç½‘ä¹‹é—´æ²Ÿé€šå’Œä¿¡ä»»çš„æˆæœ¬å°±ä¼šå¤§å¹…å¢åŠ ï¼Œæ¯ä¸ªè·¨å­ç½‘ä¿¡æ¯éƒ½éœ€è¦ç»è¿‡å±‚å±‚éªŒè¯ï¼Œæˆæœ¬å¿’å¤ªé«˜äº†ã€‚ï¼ï¸¿ï¼œ

ä½†æ˜¯ IC åˆå¿…é¡»æ˜¯å»ä¸­å¿ƒåŒ–çš„ï¼Œå¿…é¡»å¼€æ”¾ã€åŒ…å®¹ã€‚



**æ‰€ä»¥ IC ä¸ºäº†èƒ½æ‰¿è½½å¤§è§„æ¨¡è®¡ç®—ä»»åŠ¡å’Œè¶…ä½æˆæœ¬çš„è·¨å­ç½‘é€šä¿¡ï¼Œé€‰æ‹©äº†ä¸€ç§å…¼é¡¾æ€§èƒ½ä¸å»ä¸­å¿ƒåŒ–çš„æŠ˜ä¸­æ–¹å¼ â€”â€” DAO ã€‚**



ç»è¿‡æ·±æ€ç†Ÿè™‘ï¼ŒDfinity å›¢é˜Ÿé€‰æ‹©å† IC é‡Œåˆ›å»ºä¸€ä¸ª â€œ è¶…çº§å­ç½‘ â€ ï¼Œå«åšç³»ç»Ÿå­ç½‘ã€‚è¿™ä¸ªå­ç½‘æ‹¥æœ‰ IC çš„æœ€é«˜æƒé™ï¼Œç›¸å½“äº IC çš„è¶…çº§ç®¡ç†å‘˜ï¼šåˆ›å»ºå­ç½‘ã€åˆ é™¤å­ç½‘ã€ç»™å­ç½‘æ·»åŠ æ–°èŠ‚ç‚¹ã€æ‹†åˆ†å­ç½‘ã€å‡çº§å­ç½‘çš„åè®®ã€å‡çº§å‰¯æœ¬è½¯ä»¶ç‰ˆæœ¬ã€è°ƒæ•´ Cycles æ±‡ç‡ã€å…¨å±€å”¯ä¸€çš„ Canister id ã€ç”¨æˆ·çš„ principal id ã€æ¯ä¸ªå­ç½‘çš„å­ç½‘å…¬é’¥ç­‰ç­‰ï¼Œå…³ç³»åˆ°æ•´ä¸ª IC åŒºå—é“¾ç³»ç»Ÿçš„å…³é”®å‚æ•°éƒ½ç”±è¿™ä¸ªè¶…çº§ç®¡ç†å‘˜è®¾å®šæˆ–è€…å†…éƒ¨æŠ•ç¥¨å†³å®šã€‚

è¿™ç§åœ¨åŒºå—é“¾ç³»ç»Ÿåº•å±‚åµŒå…¥ DAO çš„æ··åˆæ¨¡å‹å« DAO æ§åˆ¶ç½‘ç»œï¼ˆDAO - controlled networkï¼‰ã€‚



ç®¡ç†ç€æ•´ä¸ª IC ç³»ç»Ÿçš„ DAO æœ‰ä¸ªç‚«é…·çš„åå­—ï¼šç½‘ç»œç¥ç»ç³»ç»Ÿï¼ˆNetwork Nervous System ï¼ŒNNSï¼‰ã€‚IC ä¸Šçš„å…³é”®å‚æ•°éƒ½ç”±ä¸€ä¸ª DAO ï¼Œå³æ•´ä¸ª IC ç¤¾åŒºå†³å®šã€‚ç¤¾åŒºå¯ä»¥åœ¨ç³»ç»Ÿéœ€è¦æ‰©å®¹æ—¶åšå‡ºå†³å®šå¢åŠ å­ç½‘ï¼ğŸ˜



ä¸è¿‡æœ‰ä¸€ç‚¹å¾—æ³¨æ„ä¸€ä¸‹ï¼ŒDAO ä¸æ˜¯ä¸€å¤©å»ºæˆçš„ã€‚DAO æ²¡æ³•åœ¨çŸ­æ—¶é—´å†…ç›´æ¥å˜æˆå»ä¸­å¿ƒåŒ–çš„å½¢æ€ã€‚å®ƒéœ€è¦ä¸€ä¸ªç¼“æ…¢çš„è¿‡ç¨‹ï¼Œæ…¢æ…¢å„¿çš„å»ä¸­å¿ƒåŒ–ï¼Œæ½œç§»é»˜åŒ–ã€æ¶¦ç‰©ç»†æ— å£°ã€‚åƒæ¯”ç‰¹å¸æœ€åˆä¹Ÿæ˜¯æ¸ºå°è„†å¼±ã€ä¸å ªä¸€å‡»çš„ï¼ŒæŒºè¿‡å‡ æ¬¡å±æœºã€ç»å†äº†ç¡¬åˆ†å‰ä¹‹åæ‰å½¢æˆä»Šå¤©çš„å±€é¢çš„ã€‚

> æ¯”ç‰¹å¸æœ‰å¥½å‡ æ¬¡é¢ä¸´æº¢å‡ºã€æå–åˆ«äººæ¯”ç‰¹å¸ bug ç­‰ç­‰ bug 

NNS æ˜¯ IC çš„è¶…çº§ç®¡ç†å‘˜ã€‚è¿™ä¸ª DAO æœ€å¤§çš„æŠ•ç¥¨æƒè½å…¥åäººä¹‹æ‰‹ï¼Œæ•´ä¸ª IC ç³»ç»Ÿå°±å®Œäº†ï¼ŒDAO æ˜¯é›†æˆåœ¨åŒºå—é“¾ç³»ç»Ÿåº•å±‚çš„ã€‚NNS æ˜¯ IC æœ€éœ€è¦å®‰å…¨çš„å­ç½‘ï¼Œæ‰€ä»¥ NNS å­ç½‘çš„[èŠ‚ç‚¹æ•°é‡ä¹Ÿéå¸¸å¤š](https://dashboard.internetcomputer.org/subnet/tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe)ï¼Œè®©é»‘å®¢éš¾ä»¥æ§åˆ¶æ•°é‡è¶³å¤Ÿçš„èŠ‚ç‚¹ï¼Œæœ€å¤§ç¨‹åº¦ç¡®ä¿ NNS å­ç½‘åº•å±‚çš„å®‰å…¨ã€‚

<img src="assets/1.NNS/image-20230921102952706.png" style="zoom:67%;" />

ç›®å‰æœ‰ 40 ä¸ªèŠ‚ç‚¹æœºå™¨ï¼Œæœ‰ä¸€ä¸ªåäº†ï¼Œé—®é¢˜ä¸å¤§ï¼š

<img src="assets/1.NNS/image-20230921103600826.png" style="zoom:63%;" />



åœ¨ NNS å­ç½‘å†…éƒ¨ï¼Œéƒ¨ç½²ç€ç²¾å¯†çš„å¼•æ“ï¼š DAO çš„æ™ºèƒ½åˆçº¦ã€‚

> å¯¹äº†ï¼Œåœ¨ IC ä¸Šï¼Œæ™ºèƒ½åˆçº¦å°±æ˜¯ä¸€ä¸ªå« Canister çš„è™šæ‹Ÿå®¹å™¨ã€‚å®ƒå’Œ Docker æˆ–è€… Kubernetes ç±»ä¼¼ï¼ŒCanister æ˜¯ä¸€ä¸ª Wasm å®¹å™¨ã€‚åœ¨[è¿™é‡Œ](../4.å®¹å™¨(Canister)/1.Canister.md)å¯ä»¥äº†è§£ Canister çš„æ›´å¤šå†…å®¹ï¼Œå¦‚æœä½ è¿˜æ²¡æœ‰äº†è§£è¿‡çš„è¯ã€‚



## æ·±å…¥NNSå†…éƒ¨

NNS å­ç½‘ç°åœ¨æ€»å…±æœ‰ 11 ä¸ª Canister ï¼Œåœ¨ [Dashboard](https://dashboard.internetcomputer.org/canisters?s=25&subnet=tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe) å¯ä»¥çœ‹åˆ°ã€‚

|        åå­—        |         Canister id         |            æ§åˆ¶è€… Controller            |          åŠŸèƒ½          |
| :----------------: | :-------------------------: | :-------------------------------------: | :--------------------: |
|    NNS Registry    | rwlgt-iiaaa-aaaaa-aaaaa-cai |   r7inp-6aaaa-aaaaa-aaabq-caiï¼ˆRootï¼‰   |         æ³¨å†Œè¡¨         |
|   NNS ICP Ledger   | ryjl3-tyaaa-aaaaa-aaaba-cai |   r7inp-6aaaa-aaaaa-aaabq-caiï¼ˆRootï¼‰   |      ICP ä»£å¸åŠŸèƒ½      |
|  NNS ICP Archive   | qjdve-lqaaa-aaaaa-aaaeq-cai |   r7inp-6aaaa-aaaaa-aaabq-caiï¼ˆRootï¼‰   | å­˜å‚¨ Ledger çš„å†å²è®°å½• |
|   NNS Governance   | rrkah-fqaaa-aaaaa-aaaaq-cai |   r7inp-6aaaa-aaaaa-aaabq-caiï¼ˆRootï¼‰   |    æŠ•ç¥¨ï¼Œç¥ç»å…ƒææ¡ˆ    |
|    NNS Lifeline    | rno2w-sqaaa-aaaaa-aaacq-cai |   r7inp-6aaaa-aaaaa-aaabq-caiï¼ˆRootï¼‰   |   æ§åˆ¶ Root Canister   |
| NNS Cycles Minting | rkp4c-7iaaa-aaaaa-aaaca-cai |   r7inp-6aaaa-aaaaa-aaabq-caiï¼ˆRootï¼‰   |  å°† ICP å…‘æ¢ä¸º Cycles  |
| NNS Genesis Token  | renrk-eyaaa-aaaaa-aaada-cai |   r7inp-6aaaa-aaaaa-aaabq-caiï¼ˆRootï¼‰   |      åˆ›ä¸–çºªç¥ç»å…ƒ      |
|      NNS Root      | r7inp-6aaaa-aaaaa-aaabq-cai | rno2w-sqaaa-aaaaa-aaacq-caiï¼ˆLifelineï¼‰ | æ§åˆ¶å…¶ä»– NNS Canister  |
| NNS Front-End Dapp | qoctq-giaaa-aaaaa-aaaea-cai |   r7inp-6aaaa-aaaaa-aaabq-caiï¼ˆRootï¼‰   |  å­˜å‚¨ NNS çš„å‰ç«¯ä»£ç    |
|    NNS SNS-WASM    | qaa6y-5yaaa-aaaaa-aaafa-cai |   r7inp-6aaaa-aaaaa-aaabq-caiï¼ˆRootï¼‰   |     è®°å½• SNS ä¿¡æ¯      |
|  ï¼ˆNNS Identityï¼‰  | qhbym-qaaaa-aaaaa-aaafq-cai |   r7inp-6aaaa-aaaaa-aaabq-caiï¼ˆRootï¼‰   |      ç”¨æˆ·èº«ä»½ ii       |

### NNSä¸Šçš„Canister

å®ƒä»¬çš„ä½œç”¨éƒ½å’Œç³»ç»Ÿè¿è¡Œæ¯æ¯ç›¸å…³ï¼š

1. Registry Canister ï¼šæ³¨å†Œè¡¨ Canister ã€‚æ•´ä¸ª IC çš„ç³»ç»Ÿé…ç½®éƒ½å­˜åœ¨è¿™ä¸ª Camister é‡Œï¼Œæ¯”å¦‚å“ªäº›èŠ‚ç‚¹å±äºæŸä¸ªå­ç½‘ä»¥åŠæ¯ä¸ªèŠ‚ç‚¹åº”è¿è¡Œçš„è½¯ä»¶ç‰ˆæœ¬ã€‚
2. Ledger Canister ï¼šICP è´¦æœ¬ Canister ã€‚å®ƒå­˜å‚¨ç€å„ä¸ª principal id çš„ ICP ä½™é¢ä»¥åŠ ICP äº¤æ˜“å†å²è®°å½•ã€‚
3. Archive Canisters ï¼šä¸€æ—¦äº¤æ˜“æ•°é‡å¤ªå¤šè€Œæ— æ³•ä¿å­˜åœ¨å•ä¸ª Canister ä¸­æ—¶ï¼Œäº¤æ˜“å†å²å°±å­˜å‚¨åœ¨è¿™é‡Œã€‚
4. Governance Canister ï¼šæ²»ç† Canister ã€‚æ¥æ”¶å’Œå­˜å‚¨ææ¡ˆï¼Œè¿™äº›ææ¡ˆéƒ½æ˜¯å’Œæ²»ç† IC ç½‘ç»œæœ‰å…³çš„ã€‚æ²»ç† Canister è¿˜è·Ÿè¸ªç¥ç»å…ƒï¼Œç¡®å®šè°å¯ä»¥å‚ä¸æŠ•ç¥¨æ²»ç†ã€‚
5. Cycles Minting Canister ï¼šè´Ÿè´£ç‡ƒçƒ§ ICP é“¸é€  Cycles ã€‚IC ä¸Šçš„ Cycles éƒ½ç”±è¿™ä¸ª Canister é“¸é€ ã€‚
6. Root Canister ï¼šå®ƒæ˜¯æ‰€æœ‰å…¶ä»– NNS Canister çš„æ§åˆ¶è€…ï¼Œè´Ÿè´£å‡çº§å®ƒä»¬ã€‚Canister çš„æ§åˆ¶è€…æœ‰æƒé™åˆ é™¤ Canister ã€å‡çº§æ›´æ–°ä»£ç ã€åœæ­¢ Canister ã€‚ä½† Root Canister ä¸èƒ½éšæ„å‡çº§ Canister ï¼Œå¿…é¡»è¦ Governance Canister æŠ•ç¥¨é€šè¿‡å‡çº§æŸä¸ª Canister çš„ææ¡ˆåï¼Œæ‰ä¼šè°ƒç”¨ Root Canister ï¼Œç”± Root Canister è´Ÿè´£æ‰§è¡Œå‡çº§ã€‚
7. Lifeline Canister ï¼šå®ƒæ˜¯ Root Canister çš„æ§åˆ¶è€…ï¼Œè´Ÿè´£å‡çº§å®ƒã€‚NNS é‡Œå”¯ä¸€ä¸€ä¸ªä½¿ç”¨ Motoko è¯­è¨€å†™çš„ Canister ï¼Œå½“ Rust åº•å±‚åº“å‡ºç°éå¸¸ä¸¥é‡çš„ Bug æ—¶ï¼Œå°±å¯ä»¥ç”¨è¿™ä¸ª Motoko Canister æ¥å‡çº§ Root Canister ï¼Œå†ç”¨ Root Canister å‡çº§å…¶ä»– NNS Canister æ¥æ¢å¤ IC ç³»ç»Ÿã€‚
8. Front-End Dapp ï¼šNNS å‰ç«¯ Canister ã€‚
9. Genesis Token Canister ï¼šç”¨äºåˆå§‹åŒ–åˆ›ä¸–ä¹‹å‰å°±å·²å­˜åœ¨çš„ç¥ç»å…ƒçš„ Canister ã€‚æ²»ç†è®°å½•äº†ä¸€äº›æŠ•èµ„äººã€åŸºé‡‘ä¼šã€æ—©æœŸè´¡çŒ®è€…çš„ç¥ç»å…ƒã€‚
10. SNS-WASM Canister ï¼šç®¡ç† SNS Canister ç›¸å…³çš„å†…å®¹ã€‚åˆ›å»ºã€æ›´æ–°ã€åˆ é™¤ SNS Canister éƒ½æ˜¯å®ƒè´Ÿè´£çš„ã€‚æŠ•ç¥¨é€šè¿‡åç”±å®ƒæŠŠ Wasm æ¨¡å—å®‰è£…åˆ° SNS å­ç½‘çš„ Canister é‡Œã€‚
11. ç”¨æˆ·èº«ä»½æŠ½è±¡ Canister ï¼šè®°å½•ç”¨æˆ·èº«ä»½ã€‚

### Registry Canister

å…¶ä¸­æœ€é‡è¦çš„ Canister å°±æ˜¯ Registry Canister äº†ã€‚

è¿™é‡Œè®°å½•ç€ IC ä¸Šçš„æ‰€æœ‰å­ç½‘ã€ä»¥åŠå­ç½‘çš„å…¬é’¥ã€å¯¹å­ç½‘å…¬é’¥çš„ BLS é˜ˆå€¼ç­¾åã€èŠ‚ç‚¹çš„å„ç§ä¿¡æ¯ï¼Œè¿˜æœ‰ Cycles çš„ä»·æ ¼ã€é˜²ç«å¢™é…ç½®ç­‰ç­‰ã€‚

æ–°èŠ‚ç‚¹é¦–å…ˆå¿…é¡»æŠŠè‡ªå·±çš„èº«ä»½æäº¤ç»™ NNS ï¼Œç„¶åæŠ•ç¥¨é€šè¿‡åæ‰èƒ½åŠ å…¥å­ç½‘ã€‚æ‰€æœ‰å‰¯æœ¬éƒ½ä¼šç›‘æ§ Registry Canister ï¼Œè·å–æœ€æ–°çš„é…ç½®ã€‚æ¯ä¸ªè´Ÿè´£æ‰“åŒ…å‡ºå—çš„å‰¯æœ¬ä¹Ÿå¾—æŠŠæœ€æ–°çš„é…ç½®æ”¾è¿›åŒºå—ã€‚

### Ledger Canisterå’ŒICPä»£å¸

ICP ä»£å¸ç”± Ledger Canister ç®¡ç†ï¼Œå®ƒå­˜å‚¨ä¸¤ç§ä¸œè¥¿ï¼šè´¦æˆ·å’Œäº¤æ˜“ã€‚è´¦æˆ·è®°å½•è·Ÿè¸ªæŸä¸ª principal ï¼ˆåœ¨ IC ä¸Šçš„è®¤è¯èº«ä»½ï¼‰æ‹¥æœ‰çš„ä»£å¸æ•°é‡ã€‚ä»£å¸éšåå¯ä»¥ä»ä¸€ä¸ªè´¦æˆ·å‘é€åˆ°å¦ä¸€ä¸ªè´¦æˆ·ï¼Œè¿™è¢«è®°å½•åœ¨ Ledger Canister çš„äº¤æ˜“ä¸­ã€‚

åœ¨ NNS é‡Œï¼ŒICP æœ‰ä¸‰ç§ç”¨é€”ï¼š

1. ä»»ä½•äººå¯ä»¥è´­ä¹° ICP ï¼Œè´¨æŠ¼åˆ° NNS å¹¶å‚ä¸ IC ç½‘ç»œæ²»ç†ï¼Œè´¨æŠ¼å’ŒæŠ•ç¥¨ä¼šå¾—åˆ° ICP å¥–åŠ±ã€‚
2. å‚ä¸æ²»ç†å’Œæä¾›è®¡ç®—èƒ½åŠ›çš„èŠ‚ç‚¹æœºéƒ½ä¼šå¾—åˆ° ICP å¥–åŠ±ã€‚
3. ICP å¯è½¬æ¢ä¸º Cycles ï¼Œè¿™æ˜¯ Canister è¿›è¡Œè®¡ç®—ã€é€šä¿¡å’Œå­˜å‚¨çš„ç‡ƒæ–™ã€‚

æ‰€ä»¥ä½ çœ‹ï¼ŒICP ä¸æ˜¯ç›´æ¥é›†æˆåœ¨ç³»ç»Ÿåº•å±‚çš„åŠŸèƒ½æ€§ä»£å¸ï¼ŒICP æ˜¯éƒ¨ç½²åœ¨ NNS å­ç½‘çš„æ™ºèƒ½åˆçº¦ï¼ŒCycles æ‰æ˜¯ç³»ç»Ÿçš„åŠŸèƒ½æ€§ä»£å¸ã€‚ä½†ä¸ç®¡æ€ä¹ˆè¯´ï¼ŒNNS ä¸Šçš„æ™ºèƒ½åˆçº¦æ˜¯æ•´ä¸ªåŒºå—é“¾ç³»ç»Ÿæœ€é‡è¦çš„ä¸€éƒ¨åˆ†ï¼Œä¹Ÿç›¸å½“äºæ”¯æŒ IC è¿è¡Œçš„åº•å±‚ç»„ä»¶äº†ï¼ˆåªæ˜¯ä»æ¶æ„ä¸Šçœ‹éƒ¨ç½²åœ¨åº”ç”¨å±‚ï¼‰ã€‚

> æ›´æ·±å±‚æ¬¡çš„é—®é¢˜ï¼šå¦‚æœæŸä¸ª DAO é­åˆ°é»‘å®¢æ”»å‡»ï¼Œå¤§é‡ ICP è¢«é»‘å®¢æ§åˆ¶ï¼Œæ˜¯å¦å¯ä»¥é€šè¿‡ NNS æŠ•ç¥¨æ¥æ›´æ”¹ ICP äº¤æ˜“è®°å½•ï¼Œå¼ºè¡Œè¿”è¿˜è¢«ç›—çš„ ICP ï¼Ÿ

### Governance Canister

Governance Canister è´Ÿè´£æŒæœ‰ç¥ç»å…ƒï¼Œç¡®å®šè°å¯ä»¥å‚ä¸æ²»ç†ã€‚å¦å¤–ï¼Œå®ƒè¿˜å­˜å‚¨ææ¡ˆï¼Œä»¥åŠä¸ææ¡ˆç›¸å…³çš„ä¿¡æ¯ï¼Œæ¯”å¦‚èµæˆç¥¨ç”±å¤šå°‘ã€åå¯¹ç¥¨æœ‰å¤šå°‘ç­‰ç­‰ã€‚å¦‚æœä¸€ä¸ªææ¡ˆè¢«é‡‡çº³ï¼ŒGovernance Canister å°±ä¼šè‡ªåŠ¨æ‰§è¡Œå†³å®šï¼Œæ²¡äººèƒ½é˜»æ‹¦ã€‚æœ€åï¼ŒGovernance Canister ä¼šå°†å¥–åŠ±åˆ†å‘ç»™å‚ä¸æŠ•ç¥¨ã€ä¸ºå†³ç­–åšå‡ºè´¡çŒ®çš„ç¥ç»å…ƒã€‚



### å®šä¹‰NNSä¸Šçš„Canister id

é¡ºä¾¿æä¸€å˜´ï¼ŒNNS å­ç½‘é‡Œçš„ Canister åº”è¯¥æ˜¯ç¬¬ä¸€ä¸ªéƒ¨ç½²åœ¨ IC ä¸Šçš„ Canister ã€‚NNS é‡Œè¿™äº› Canister çš„ Canister id æ˜¯ç›´æ¥åœ¨[ä»£ç ](https://github.com/dfinity/ic/blob/master/rs/nns/constants/src/lib.rs)é‡Œå®šä¹‰å¥½çš„ã€‚Canister id çš„æ˜¯ç”± u64 ç±»å‹çš„ç´¢å¼•è½¬æ¢å‡ºæ¥çš„ï¼Œä¹Ÿå¯ä»¥æŠŠ Canister è½¬æ¢å› u64 ã€‚

è¿™æ®µä»£ç å®šä¹‰äº† NNS å­ç½‘å„ Canister çš„åŸºç¡€ä¿¡æ¯ï¼Œæ˜¯åˆå§‹åŒ– NNS å­ç½‘çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚

```rust
// å®šä¹‰NNSå­ç½‘å†…å„ä¸ªCanisterçš„ç´¢å¼•
pub const REGISTRY_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 0;
pub const GOVERNANCE_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 1;
pub const LEDGER_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 2;
pub const ROOT_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 3;
pub const CYCLES_MINTING_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 4;
pub const LIFELINE_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 5;
pub const GENESIS_TOKEN_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 6;
pub const IDENTITY_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 7;
pub const NNS_UI_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 8;
pub const SNS_WASM_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 10;

pub const NUM_NNS_CANISTERS: usize = ALL_NNS_CANISTER_IDS.len();
// æ ¹æ®ç´¢å¼•,å®šä¹‰å„ä¸ªCanisterçš„ID
pub const REGISTRY_CANISTER_ID: CanisterId =
    CanisterId::from_u64(REGISTRY_CANISTER_INDEX_IN_NNS_SUBNET);
pub const GOVERNANCE_CANISTER_ID: CanisterId =
    CanisterId::from_u64(GOVERNANCE_CANISTER_INDEX_IN_NNS_SUBNET);
pub const LEDGER_CANISTER_ID: CanisterId =
    CanisterId::from_u64(LEDGER_CANISTER_INDEX_IN_NNS_SUBNET);
pub const ROOT_CANISTER_ID: CanisterId = CanisterId::from_u64(ROOT_CANISTER_INDEX_IN_NNS_SUBNET);
pub const CYCLES_MINTING_CANISTER_ID: CanisterId =
    CanisterId::from_u64(CYCLES_MINTING_CANISTER_INDEX_IN_NNS_SUBNET);
pub const LIFELINE_CANISTER_ID: CanisterId =
    CanisterId::from_u64(LIFELINE_CANISTER_INDEX_IN_NNS_SUBNET);
pub const GENESIS_TOKEN_CANISTER_ID: CanisterId =
    CanisterId::from_u64(GENESIS_TOKEN_CANISTER_INDEX_IN_NNS_SUBNET);
pub const IDENTITY_CANISTER_ID: CanisterId =
    CanisterId::from_u64(IDENTITY_CANISTER_INDEX_IN_NNS_SUBNET);
pub const NNS_UI_CANISTER_ID: CanisterId =
    CanisterId::from_u64(NNS_UI_CANISTER_INDEX_IN_NNS_SUBNET);
pub const SNS_WASM_CANISTER_ID: CanisterId =
    CanisterId::from_u64(SNS_WASM_CANISTER_INDEX_IN_NNS_SUBNET);
```

### NNSæ— Gas

NNS æ˜¯ç³»ç»Ÿå­ç½‘ï¼Œé‡Œé¢éƒ¨ç½²çš„ Canister éƒ½æ˜¯å’Œ DAO ã€ç³»ç»Ÿè¿è¡Œç›¸å…³çš„ï¼Œå¼€å‘è€…ä¸èƒ½åœ¨ NNS éƒ¨ç½² Canister ã€‚æ‰€ä»¥ NNS ä¹Ÿæ²¡æœ‰ Gas è´¹ï¼Œä¸æ¶ˆè€— Cycles ã€‚



## NNS æ²»ç†



ä½ å¯ä»¥é€šè¿‡åœ¨ç¥ç»å…ƒä¸­è´¨æŠ¼ ICP ä»£å¸ï¼Œå‚ä¸åˆ° NNS çš„æ²»ç†ä¸­æ¥ï¼Œå‚ä¸æ²»ç†ä¼šæœ‰ ICP ä»£å¸å¥–åŠ±ã€‚ä½œä¸ºç¥ç»å…ƒæŒæœ‰è€…ï¼Œä½ å¯ä»¥æå‡ºå…³äº IC çš„ææ¡ˆï¼Œè®©å¤§å®¶æŠ•ç¥¨ï¼Œæ¯”å¦‚å­ç½‘çš„æ‹“æ‰‘ç»“æ„æˆ–åè®®çš„æ”¹å˜ã€‚è´¨æŠ¼æ›´å¤š ICP çš„ç¥ç»å…ƒæŠ•ç¥¨æƒæ›´å¤§ã€‚é™¤äº†ä»£å¸æ•°é‡ï¼ŒæŠ•ç¥¨æƒè¿˜å—ç¥ç»å…ƒå…¶ä»–ç‰¹å¾å½±å“ï¼Œæ¯”å¦‚æ„¿æ„è´¨æŠ¼æ›´é•¿æ—¶é—´çš„ç¥ç»å…ƒæŒæœ‰äººä¼šæœ‰æ›´å¤§çš„æŠ•ç¥¨æƒã€‚



æ¯ä¸ªææ¡ˆéƒ½æœ‰ç¡®å®šçš„æŠ•ç¥¨æœŸé™ã€‚åœ¨æŠ•ç¥¨æœŸç»“æŸæ—¶ï¼Œå¦‚æœç®€å•å¤šæ•°èµæˆè¯¥ææ¡ˆï¼Œä¸”èµæˆç¥¨æ•°è¶…è¿‡äº†æ€»æŠ•ç¥¨æƒçš„ 3% ï¼Œè¿™ä¸ªææ¡ˆå°±ä¼šè¢«é‡‡çº³ã€‚å½“ç„¶ï¼Œå¦‚æœç»å¯¹å¤šæ•°ï¼ˆè¶…è¿‡æ€»æŠ•ç¥¨ä¸€åŠï¼‰èµæˆæˆ–åå¯¹æŸä¸ªææ¡ˆï¼Œææ¡ˆå°†ç«‹å³è¢«é€šè¿‡æˆ–å¦å†³ã€‚

ææ¡ˆä¸€æ—¦é€šè¿‡ï¼Œæ²»ç† Canister ä¼šè‡ªåŠ¨æ‰§è¡Œå†³ç­–ã€‚æ¯”å¦‚ï¼Œææ¡ˆæè®®æ”¹å˜ç½‘ç»œæ‹“æ‰‘ç»“æ„å¹¶è·å¾—é€šè¿‡ï¼Œæ²»ç†å®¹å™¨å°±ä¼šç”¨æ–°é…ç½®æ›´æ–°æ³¨å†Œè¡¨å®¹å™¨ã€‚



IC çš„ä¸€ä¸ªéª„å‚²ä¹‹å¤„å°±æ˜¯èƒ½å®ç°ä½æˆæœ¬çš„æ— ç¼æ‰©å±•ã€‚å®ƒå¯ä»¥è‡ªåŠ¨äº§ç”Ÿæ–°å­ç½‘æ¥åº”å¯¹ç½‘ç»œè´Ÿè½½ï¼Œè€Œä¸”æ‰©å®¹è¿‡ç¨‹ä¸­ä¸éœ€è¦åœæ­¢æœåŠ¡ã€‚åœ¨ Dfinity ä¸Šï¼Œå­ç½‘çš„å¢åŠ ä¸åˆå¹¶æ˜¯æŒ‰éœ€è¿›è¡Œçš„ã€‚å‚ä¸ NNS çš„ç¥ç»å…ƒå¯ä»¥æ ¹æ®ç½‘ç»œè´Ÿè½½æƒ…å†µå‘èµ·æ‰©å®¹ææ¡ˆï¼Œä»¥å¹³è¡¡æ•´ä¸ªç½‘ç»œã€‚



è¿™ç§å¼ºå¤§çš„æ‰©å®¹èƒ½åŠ›è®©è¶…å¤§å‹åŒºå—é“¾åº”ç”¨æˆä¸ºå¯èƒ½ã€‚å¼€å‘è€…å¯ä»¥ç”¨æ™ºèƒ½åˆçº¦æ„å»ºå¦‚ token åŒ–çš„ç¤¾äº¤åª’ä½“ç­‰åº”ç”¨ï¼Œå°†ç¤¾äº¤åª’ä½“ä¸ä¼ ç»Ÿçš„æ™ºèƒ½åˆçº¦åº”ç”¨ï¼ˆå¦‚ DeFiï¼‰æ•´åˆåœ¨ä¸€èµ·ï¼Œå¤§å¤§æ‹“å®½äº†ä¸šåŠ¡çš„æƒ³è±¡åŠ›ã€‚

å‚ä¸æ²»ç†çš„ç”¨æˆ·å¯ä»¥é€šè¿‡æŠµæŠ¼ ICP ä»£å¸æˆä¸ºç¥ç»å…ƒï¼Œå‘èµ·ææ¡ˆå¹¶å‚ä¸æŠ•ç¥¨ã€‚ä½ å¯ä»¥ç›´æ¥æŠ•ç¥¨ï¼Œä¹Ÿå¯ä»¥è·Ÿéšä½ ä¿¡ä»»çš„èŠ‚ç‚¹çš„ç¥¨ã€‚æ³¨æ„ï¼Œè¿™é‡Œæ˜¯â€œè·Ÿéšâ€è€Œä¸æ˜¯â€œä»£ç†â€ã€‚è¢«è·Ÿéšçš„èŠ‚ç‚¹ä¸ä¼šå¾—åˆ°ä½ çš„ä»£å¸ï¼Œä¹Ÿä¸ä¼šå› ä¸ºä½ çš„å…³æ³¨è·å¾—æ›´å¤š ICP å¥–åŠ±ã€‚è¿™ç§æ–¹å¼æœ‰åŠ©äºå½¢æˆä¸€ä¸ªåˆ†æ•£çš„çŸ¥è¯†ç½‘ç»œï¼Œæœ‰åŠ©äºåšå‡ºæ˜æ™ºçš„å†³ç­–ã€‚

å€¼å¾—ä¸€æçš„æ˜¯ï¼ŒNNS çš„æ²»ç†ç¥ç»å…ƒè¿˜æ”¯æŒ AI å’Œè„šæœ¬ã€‚è¿™äº›æœºå™¨äººæ›´æ“…é•¿å‚æ•°çš„å¾®è°ƒï¼Œæ¯”å¦‚è·å–äº¤æ˜“æ‰€ ICP çš„ä»·æ ¼æ¥è°ƒèŠ‚ Gas çš„ä»·æ ¼ã€‚è¿™å°†æå¤§æå‡æ²»ç†æ•ˆç‡ï¼Œå¸®åŠ©ç½‘ç»œå®ç°è‡ªæˆ‘è¿›åŒ–ã€‚







## NNS é’±åŒ…













**é¦–å…ˆï¼Œæ›´é«˜å±‚æ¬¡çš„çœŸç›¸â€¦â€¦**

æˆ‘ä»¬åº”è¯¥å¼ºè°ƒ[NNS æ²»ç†ç³»ç»Ÿ](https://medium.com/dfinity/getting-started-on-the-internet-computers-network-nervous-system-app-wallet-61ecf111ea11)ï¼ˆæ‰€ä»¥[æ¯ä¸ªäºº](https://medium.com/dfinity/understanding-the-internet-computers-network-nervous-system-neurons-and-icp-utility-tokens-730dab65cae8)ï¼‰å†³å®š[æˆ‘ä»¬åˆ›å»ºçš„å­ç½‘çš„å¤§å°](https://medium.com/dfinity/a-technical-overview-of-the-internet-computer-f57c62abc20f)ã€‚æ‰€ä»¥å¦‚æœäººä»¬æƒ³è¦å®ƒï¼Œä»–ä»¬å¯ä»¥åˆ›é€ å®ƒã€‚æˆ‘ä»¬ä¸èƒ½åˆ›å»ºæ›´å¤§çš„å­ç½‘å¹¶æ²¡æœ‰çœŸæ­£çš„æŠ€æœ¯åŸå› ã€‚åªæ˜¯å‡ºäºå®ç”¨æ€§è€ƒè™‘ï¼Œæˆ‘ä»¬ç°åœ¨é€‰æ‹©ä¸è¿™æ ·åšï¼ˆä¾‹å¦‚ï¼Œæˆ‘ä»¬æµ‹è¯•æ—¶è¡¨é¢ç§¯è¾ƒå°ï¼Œéšç€æ›´å¤šèŠ‚ç‚¹æä¾›å•†ä¸Šçº¿è€Œæœ€å¤§åŒ–å­ç½‘ç­‰ï¼‰ã€‚å› æ­¤ï¼Œè¿™æ„å‘³ç€å¦‚æœæˆ‘ä»¬éœ€è¦æ·»åŠ æ›´å¤šï¼Œæˆ‘ä»¬å°±ä¼šè¿™æ ·åšã€‚å¦‚æœå­ç½‘ä¸­çš„èŠ‚ç‚¹æ•°é‡æˆä¸ºç”Ÿæ€ç³»ç»Ÿå’Œé‡‘èä¸–ç•Œçš„éšœç¢ï¼Œé‚£ä¹ˆæˆ‘ä»¬ï¼ˆç¤¾åŒºï¼‰å¯ä»¥æå‡ºå»ºè®®ã€‚å› æ­¤ï¼Œé£é™©åœ¨äºç¤¾åŒºåŒæ„ï¼Œè€Œä¸æ˜¯ä»»ä½•åŠ å¯†æˆ–æŠ€æœ¯ã€‚

åœ¨è®¸å¤šæ–¹é¢ï¼ŒNNS æ˜¯è¯´â€œæˆ‘ä»¬ä¿¡ä»»ç¤¾åŒºã€‚æˆ‘ä»¬çŸ¥é“äº‹æƒ…å¿…é¡»æ”¹å˜ã€‚â€è™½ç„¶æˆ‘ä»¬å¸®åŠ©å¯åŠ¨å®ƒï¼Œä½†å¾ˆæ˜æ˜¾ï¼Œæˆ‘ä»¬æ°¸è¿œä¸èƒ½è€ƒè™‘æ‰€æœ‰äº‹æƒ…ï¼Œé‡è¦çš„æ˜¯ IC æ¯”æˆ‘ä»¬æ›´å¥½ï¼ˆè€Œä¸”æˆ‘ä»¬çš„æ—¶é—´èµ„æºï¼‰ã€‚

**ç°åœ¨æ˜¯ç»†å¾®å·®åˆ«ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä¸€èµ·çœ‹çœ‹ä¹é«˜ç§¯æœ¨ï¼š**

1. ä¼¼ä¹æœ‰ä¸€ä¸ªå‡è®¾ï¼Œå³ IC éœ€è¦ 7 ä¸ªå‰¯æœ¬ï¼Œå› ä¸ºè¿™å°±æ˜¯å®ƒä»¬ç›®å‰åœ¨ä¸»ç½‘ä¸Šçš„æƒ…å†µã€‚æˆ‘ä»¬çš„ç›®çš„æ˜¯åœ¨ç½‘ç»œä¸Šå·¥ä½œæ—¶å¯¹æ­¤è¿›è¡Œå¾ˆå¤§çš„æ”¹å˜ã€‚ä¾‹å¦‚ï¼ŒNNS å­ç½‘è¢«è®¤ä¸ºè¶³å¤Ÿé‡è¦ï¼Œå¯ä»¥æ‹¥æœ‰æ›´å¤šå­ç½‘ã€‚æˆ‘ä»¬å·²ç»æµ‹è¯•äº†å¾ˆå¤šå¾ˆå¤šã€‚
2. åè®®è¯•å›¾æœ€å¤§åŒ–æ‰€æœ‰æƒçš„ç‹¬ç«‹æ€§ï¼Œè¿™ä¸å…¶ä»–åŒºå—é“¾ä¸åŒï¼Œåœ¨å…¶ä»–åŒºå—é“¾ä¸­ï¼Œä¾‹å¦‚éªŒè¯å™¨éƒ½åœ¨ AWS æˆ–å·¨å‹çŸ¿æ± ä¸­è¿è¡Œã€‚å¦‚æœæŸäº›é‡‘èåº”ç”¨ç¨‹åºç©ºé—´è¿˜ä¸å…³å¿ƒè¿™ä¸€ç‚¹ï¼Œé‚£æ˜¯å®Œå…¨æ­£ç¡®çš„ï¼Œä½†ä½œä¸ºç—´è¿·äºå®‰å…¨çš„äººï¼Œæˆ‘ä»¬å…³å¿ƒä»»ä½•å¼±ç‚¹æˆ–ç¯¡æ”¹çš„å¯èƒ½æ€§ã€‚
3. æˆ‘ä»¬çš„ç›®çš„æ˜¯æœ€å¤§åŒ–èŠ‚ç‚¹æ‰€æœ‰æƒçš„ç‹¬ç«‹æ€§ä»¥åŠåœ°ç†å·®å¼‚ã€‚æˆ‘ä»¬ä¸å¸Œæœ›æ‰€æœ‰èŠ‚ç‚¹ï¼ˆæˆ–å¤§å¤šæ•°ï¼‰éƒ½åœ¨æŸä¸ªåœ°åŒºã€å›½å®¶ç­‰ã€‚
4. é™¤éåŸä½œè€…å…¬å¼€ APIï¼Œå¦åˆ™ç¬¬ä¸‰æ–¹å¼€å‘äººå‘˜æ— æ³•æ£€æŸ¥å®¹å™¨çš„çŠ¶æ€ã€‚
5. æ˜¯çš„ï¼Œç›®å‰èŠ‚ç‚¹æ“ä½œå‘˜ç†è®ºä¸Šå¯ä»¥æ£€æŸ¥ç½çš„çŠ¶æ€ï¼ˆå›°éš¾ä½†å¾ˆæœ‰å¯èƒ½ï¼‰ã€‚æˆ‘ä»¬å·²ç»å…¬å¼€è°ˆè®ºè¿‡æˆ‘ä»¬æ‰“ç®—åœ¨èŠ‚ç‚¹ä¸Šè¿›è¡ŒåŠ å¯†è®¡ç®—ï¼ˆSGX æ ·å¼ï¼‰ï¼Œä½†è¿™è¿˜æ²¡æœ‰å®ç°ï¼ˆè¯·å‚é˜…[æ­¤çº¿ç¨‹ä¸­](https://www.reddit.com/r/dfinity/comments/nerppg/ama_we_are_manu_paul_and_diego_we_have_worked/gykc779?utm_source=share&utm_medium=web2x&context=3)å…³äºå¯ä¿¡æ‰§è¡Œç¯å¢ƒçš„è¯„è®ºã€‚

å¸Œæœ›è¿™æœ‰åŠ©äºç”¨ä¸€äº›æ€¥éœ€çš„ç»†å¾®å·®åˆ«æ¥ç€è‰²ï¼Œæˆ‘ä»¬å¯ä»¥ä¸€èµ·çœ‹ä¸€ä¸‹è¿™äº›ç‰‡æ®µã€‚æœ‰äººè¯´â€œ*ä½ å¿˜äº†å¸¦ 1* â€æˆ–â€œ*è¿™å¯èƒ½ç°åœ¨å¯ä»¥ï¼Œä½† IC éœ€è¦åœ¨ 3 ä¸ªæœˆå†…æ›´æ¢ã€‚* â€è¿™å®Œå…¨æœ‰æ•ˆã€‚è¿™å°±æ˜¯ IC æœ‰ NNS çš„åŸå› ã€‚



æˆ‘ä»¬å¯ä»¥å®¹å¿ 3f+1 å¤§å°çš„å­ç½‘ä¸­çš„ f ä¸ªæ¶æ„å‰¯æœ¬ï¼Œå› æ­¤å¯¹äº 7 ä¸ªèŠ‚ç‚¹çš„å­ç½‘ï¼Œ2 ä¸ªæ¶æ„å‰¯æœ¬å¯ä»¥ï¼Œä½† 3 ä¸ªåˆ™ä¸è¡Œã€‚





---



åè®®å‡çº§

Internet Computer åŒºå—é“¾ç”±ç½‘ç»œç¥ç»ç³»ç»Ÿï¼ˆNNSï¼‰è¿›è¡Œæ²»ç†ï¼Œè¿™æ˜¯å…¶ç®—æ³•æ²»ç†ç³»ç»Ÿã€‚NNS çš„è®¸å¤šèŒè´£ä¹‹ä¸€æ˜¯åœ¨ç¤¾åŒºé‡‡çº³å‡çº§ææ¡ˆæ—¶ï¼Œåè°ƒå°† Internet Computer å‡çº§åˆ°æ–°åè®®ç‰ˆæœ¬ã€‚å¯¹ä»»ä½•åŒºå—é“¾è¿›è¡Œå‡çº§éƒ½éœ€è¦è§£å†³å»ä¸­å¿ƒåŒ–ç³»ç»Ÿç‰¹æ€§æ‰€å¸¦æ¥çš„ä¸€ç³»åˆ—æŒ‘æˆ˜æ€§é—®é¢˜ï¼ŒåŒ…æ‹¬å¦‚ä½•å…è®¸å¯¹åè®®è¿›è¡Œä»»æ„æ›´æ”¹ï¼Œä¿ç•™æ‰€æœ‰å®¹å™¨æ™ºèƒ½åˆçº¦çš„çŠ¶æ€ï¼Œæœ€å¤§é™åº¦åœ°å‡å°‘åœæœºæ—¶é—´ï¼Œå¹¶è‡ªä¸»æ¨å‡ºå‡çº§ã€‚



åœ¨ä»»ä½•å¤§å‹åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œç”±äºç¡¬ä»¶æ•…éšœã€ç½‘ç»œè¿æ¥é—®é¢˜æˆ–æ‰€æœ‰è€…å†³å®šå°†å‰¯æœ¬ä»ç½‘ç»œä¸­ç§»é™¤ï¼Œå•ä¸ªå‰¯æœ¬çš„æ•…éšœæ˜¯ä¸å¯é¿å…çš„ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒIC çš„ç½‘ç»œç¥ç»ç³»ç»Ÿé€‰æ‹©ä¸€ä¸ªå¤‡ç”¨å‰¯æœ¬æ¥æ›¿æ¢å…¶å­ç½‘ä¸­çš„æ•…éšœå‰¯æœ¬ã€‚æ–°å‰¯æœ¬éšååŠ å…¥å­ç½‘ï¼Œå¹¶ä¸ç°æœ‰å‰¯æœ¬è¿›è¡ŒçŠ¶æ€åŒæ­¥ï¼Œå¼€å§‹ä¸ºå­ç½‘åŒºå—é“¾çš„å…±è¯†åè®®åšå‡ºè´¡çŒ®ã€‚



**ä½æˆæœ¬çš„æ— ç¼æ‰©å±•**

äº’è”ç½‘è®¡ç®—æœºå¯ä»¥å®ç°æ— ç¼ä¸æ»‘åœ°æ‰©å±•ï¼Œä¸ä»…èƒ½æ ¹æ®ç½‘ç»œè´Ÿè½½æƒ…å†µè‡ªåŠ¨çš„äº§ç”Ÿæ–°å­ç½‘ï¼Œåœ¨æ‰©å®¹è¿‡ç¨‹ä¸­ä¹Ÿä¸éœ€è¦åœæ­¢ä½ çš„æœåŠ¡ã€‚å¯¹ç”¨æˆ·ä¸å¼€å‘è€…æ¥è¯´ï¼Œæ‰©å®¹çš„è¿‡ç¨‹æ˜¯æ¯«æ— æ„Ÿè§‰çš„ã€‚

è¿‡å»æˆ‘ä»¬çš„æ€ç»´å¸¸å¸¸è¢«é™å®šåœ¨å›ºå®šæ•°é‡çš„é“¾ä¸Šï¼Œä»è€Œé’‰æ­»äº†æ•´ä¸ªç½‘ç»œçš„ TPSï¼Œè€Œå®é™…ä¸Š TPS åº”è¯¥æ˜¯æŒ‰éœ€æ‰©å±•çš„ã€‚åœ¨ DFINITY ä¸Šå­ç½‘çš„å¢åŠ ä¸åˆå¹¶æ˜¯æŒ‰éœ€è¿›è¡Œçš„ï¼Œå‚ä¸ NNS çš„ç¥ç»å…ƒå¯ä»¥æ ¹æ®å½“å‰çš„ç½‘ç»œè´Ÿè½½æƒ…å†µå‘èµ·æ‰©å®¹ææ¡ˆï¼Œæ¥å¹³è¡¡æ•´ä¸ªç½‘ç»œçš„è´Ÿè½½ã€‚

è¿™ç§è¿‘ä¹æ— é™åœ°æ‰©å®¹èƒ½åŠ›ï¼Œä¹Ÿè®©åŒºå—é“¾çš„è¶…å¤§å‹åº”ç”¨æˆä¸ºå¯èƒ½ã€‚å¼€å‘è€…å¯ä»¥ä½¿ç”¨æ™ºèƒ½åˆçº¦æ¥æ„å»ºtoken åŒ–çš„ç¤¾äº¤åª’ä½“ï¼Œå°†ç¤¾äº¤åª’ä½“ä¸ä¼ ç»Ÿçš„æ™ºèƒ½åˆçº¦åº”ç”¨ï¼ˆå¦‚DeFiï¼‰èåˆåœ¨ä¸€èµ·ï¼Œè¿™å°†å¸¦æ¥æ— é™çš„ä¸šåŠ¡æƒ³è±¡åŠ›ã€‚



æ³¨æ„ï¼Œè¿™é‡Œæ˜¯â€œè·Ÿéšâ€è€Œä¸æ˜¯â€œä»£ç†â€ã€‚è¢«è·Ÿéšçš„èŠ‚ç‚¹ä¸ä¼šå¾—åˆ°ä½ çš„ä»£å¸ï¼Œä¹Ÿä¸ä¼šå› ä¸ºä½ çš„å…³æ³¨è·å¾—æ›´å¤šçš„ ICP å¥–åŠ±ã€‚è¢«â€œè·Ÿéšâ€çš„èŠ‚ç‚¹è¿˜èƒ½å†å»â€œè·Ÿéšâ€åˆ«äººï¼Œè¿™æœ€ç»ˆå½¢æˆä¸€ä¸ªåˆ†æ•£çš„çŸ¥è¯†ç½‘ç»œï¼Œå¸®åŠ©åšå‡ºè¶³å¤Ÿæ˜æ™ºçš„å†³ç­–ã€‚

NNS çš„æ²»ç†ç¥ç»å…ƒèƒ½æ”¯æŒ AI ä¸è„šæœ¬ï¼Œè¿™äº›æœºå™¨äººæ›´æ“…é•¿å‚æ•°çš„å¾®è°ƒï¼Œæ¯”å¦‚è·å–äº¤æ˜“æ‰€ ICP çš„ä»·æ ¼ï¼Œæ¥è°ƒèŠ‚ Gas çš„ä»·æ ¼ã€‚è¿™å°†å¤§å¤§æå‡æ²»ç†æ•ˆç‡ï¼Œå¹¶èƒ½å¸®åŠ©ç½‘ç»œå®ç°è‡ªæˆ‘è¿›åŒ–ã€‚





















## Proposals

### Format

Each proposal submitted to the NNS has the following fields:

* **Summary:** Text providing a short description of the proposal, composed using a maximum of 280 bytes.
* **URL:** The web address of additional content required to evaluate the proposal, specified using HTTPS. For example, the address might describe content supporting the assignment of a DCID (data center id) to a new data center.
* **Proposer:** The ID of the neuron that submitted the proposal. When a proposal is submitted, a â€œchargeâ€ is placed on its balance in case it is rejected. So the balance needs to be big enough to pay the charge on (all) rejection(s). A neuron is required to have a dissolve delay â‰¥ 6 months to vote, and this applies to submitting proposals too.
* **Proposal Type:** The type of the proposal. This infers what topic it belongs to (e.g., #NodeAdmin), the system function that will process the proposal if it is adopted, and the type and structure of the parameters that will be passed to that function.
* **Parameters:** The parameters that will be passed to the system function that will be invoked if the proposal is adopted, as determined by its type. When a proposal is submitted, the NNS checks the parameters.

The NNS assigns a unique identity to each proposal that it receives.

The NNS assigns a unique identity to each proposal that it receives.

### Topics

The topic of a proposal, which is inferred from its type, determines how it will be processed. For example, the NNS may require voters to have a greater degree of agreement, or to try to process proposals faster, for some topics. Also, neurons follow other neurons on a per-topic basis. Initial topics include:

* **#NeuronManagement:** A special topic by means of which a neuron can be managed by the followees for this topic (in this case, there is no fallback to default). Votes on this topic are not included in the voting history of the neuron. For proposals on this topic, only the neuronâ€™s followees on the topic that the proposals pertain to are allowed to vote. Because the set of eligible voters of proposals on this topic is restricted, proposals on this topic have a shorter than normal voting period.
* **ExchangeRate:** All proposals provide information in â€œreal timeâ€ about the market value of ICP, as measured by an International Monetary Fund (IMF) Special Drawing Right (SDR) , which allows the NNS to convert ICP to cycles (which power computation) at a rate that keeps their real-world cost constant. Because proposals on this topic are very frequent, they have a shorter voting period, and votes on this topic are not included in the voting history of the neuron.
* **#NetworkEconomics:** Proposals that administer network economics â€” for example, determining what rewards should be paid to node operators.
* **#Governance:** All proposals that administer governance â€” for example, motions and the configuration of certain parameters.
* **#NodeAdmin:** All proposals that administer node machines somehow, including but not limited to upgrading or configuring the OS, upgrading or configuring the virtual machine framework, and upgrading or configuring the node replica software.
* **#ParticipantManagement:** All proposals that administer network participants â€” for example, granting and revoking DCIDs (data center identities) or NPIDs (node provider identities).
* **#SubnetManagement:** All proposals that administer network subnets â€” for example, creating new subnets, adding and removing subnet nodes, and splitting subnets.
* **#NetworkCanisterManagement:** Installing and upgrading â€œsystemâ€ [canisters](https://wiki.internetcomputer.org/wiki/NNS_Canisters) that belong to the network â€” for example, upgrading the NNS.
* **#KYC:** Proposals that update KYC information for regulatory purposes â€” for example, during the initial Genesis distribution of ICP in the form of neurons.
* **#NodeProviderRewards:** Topic for proposals to reward node providers.

### Types

Initial proposal types include:

* **ManageNeuron (#NeuronManagement, Restricted Voting)** This type of proposal calls a major function on a specified target neuron. Only the followees of the target neuron may vote on these proposals, which effectively provides the followees with control over the target neuron. This can provide a convenient and highly secure means for a team of individuals to manage an important neuron. For example, a neuron might hold a large balance, or belong to an organization of high repute, and be publicized so that many other neurons can follow its vote. In both cases, managing the private key of the principal securely could be problematic. (Either a single copy is held, which is very insecure and provides for a single party to take control, or a group of individuals must divide responsibility â€” for example, using threshold cryptography, which is complex and time consuming). To address this using this proposal type, the important neuron can be configured to follow the neurons controlled by individual members of a team. Now they can submit proposals to make the important neuron perform actions, which are adopted if and only if a majority of them vote to adopt. (Submitting such a proposal costs a small fee, to prevent denial-of-service attacks.) Nearly any command on the target neuron can be executed, including commands that change the follow rules, allowing the set of team members to be dynamic. Only the final step of dissolving the neuron once its dissolve delay reaches zero cannot be performed using this type of proposal, since this would allow control/â€œownershipâ€ over the locked balances to be transferred. (The only exception to this rule applies to not-for-profit organizations, which may be allowed to dissolve their neurons without using the initial private key.) To prevent a neuron falling under the malign control of the principalâ€™s private key by accident, the private key can be destroyed so that the neuron can only be controlled by its followees, although this makes it impossible to subsequently unlock the balance.

* ManageNetworkEconomics (#NetworkEconomics)

     

    This is a single proposal type which can update one or several economic parameters:

    * Reject cost: The amount of ICP the proposer of a rejected proposal will be charged â€” to prevent the spamming of frivolous proposals.
    * Minimum Neuron Stake: Set the minimum number of ICP required for creation of a neuron. The same limit must also be respected when increasing dissolve delay or changing the neuron state from dissolving to aging.
    * Neuron Management fee: The cost in ICP per neuron management proposal. Here the NNS is doing work on behalf of a specific neuron, and a small fee will be applied to prevent overuse of this feature (i.e., spam).
    * Minimum ICP/SDR rate: To prevent mistakes, there is a lower bound for the ICP/SDR rate, managed by network economic proposals.
    * Dissolve delay of spawned neurons: The dissolve delay of a neuron spawned from the maturity of an existing neuron.
    * Maximum node provider rewards: The maximum rewards to be distributed to node providers in a single distribution event (proposal).
    * Transaction fee: The transaction fee that must be paid for each ledger transaction.
    * Maximum number of proposals to keep per topic: The maximum number of proposals to keep, per topic. When the total number of proposals for a given topic is greater than this number, the oldest proposals that have reached a â€œfinalâ€ state may be deleted to save space.

* **Motion (#Governance)** A motion is a text that can be adopted or rejected. No code is executed when a motion is adopted. An adopted motion should guide the future strategy of the Internet Computer ecosystem.

* **ApproveGenesisKYC (#KYC)** When new neurons are created at Genesis, they have GenesisKYC=false. This restricts what actions they can perform. Specifically, they cannot spawn new neurons, and once their dissolve delays are zero, they cannot be disbursed and their balances unlocked to new accounts. This proposal sets GenesisKYC=true for batches of principals.

(Special note: The Genesis event disburses all ICP in the form of neurons, whose principals must be KYCed. Consequently, all neurons created after Genesis have GenesisKYC=true set automatically since they must have been derived from balances that have already been KYCed.)

* **AddOrRemoveNodeProvider (#Participant Management)** Assign (or revoke) an identity to a node provider, associating key information regarding the legal person associated that should provide a way to uniquely identify it.

* **RewardNodeProvider (#NodeProviderRewards)** Propose to reward a Gen-1 node provider an amount of ICP as compensation for providing Gen-1 nodes to the IC.

* **SetDefaultFollowees (#Governance)** Specify the list of followees that a freshly created neuron should have.

The following is a list of proposal types that call other NNS canisters:

* **CreateSubnet (#SubnetManagement)** Combine a specified set of nodes, typically drawn from data centers and operators in such a way as to guarantee their independence, into a new decentralized subnet. The execution of this external update first initiates a new instance of the distributed key generation protocol. The transcript of that protocol is written to a new subnet record in the registry, together with initial configuration information for the subnet, from where the nodes comprising the subnet pick it up.

* **AddNodeToSubnet (#SubnetManagement)** Add a new node to a subnet. The node cannot be currently assigned to a subnet. The execution of this proposal changes an existing subnet record to add a node. From the perspective of the NNS, this update is a simple update of the subnet record in the registry.

* **InstallNetworkCanister (#NetworkCanisterManagement)** A proposal to add a new canister to be installed and executed in the NNS subnetwork. The root canister, which controls all canisters on the NNS except for itself, handles this proposal type. The call also expects the Wasm module that shall be installed.

* **UpgradeNetworkCanister (#NetworkCanisterManagement)** A proposal to upgrade an existing canister in the NNS subnetwork. This proposal type is executed by the root canister. Beyond upgrading the Wasm module of the target canister, the proposal can also set the authorization information and the allocations.

* **BlessReplicaVersion (#NodeAdmin)** A proposal to bless a new version to which the replicas can be upgraded. The proposal registers a replica version (identified by the hash of the installation image) in the registry. Besides creating a record for that version, the proposal also appends that version to the list of â€œblessed versionsâ€ that can be installed on a subnet. By itself, this proposal does not effect any upgrade. (In the future, there will only be one blessed version of the replica software at any given time.)

* **RecoverSubnet (#SubnetManagement)** Update a subnetâ€™s recovery CUP (used to recover subnets that have stalled). Nodes that find a recovery CUP for their subnet will load that CUP from the registry and restart the replica from that CUP.

* **UpdateSubnetConfig (#SubnetManagement)** Update a subnetâ€™s configuration. This proposal updates the subnet record in the registry, with the changes being picked up by the nodes on the subnet when they reference the respective registry version. Subnet configuration comprises protocol parameters that must be consistent across the subnet (e.g., message sizes).

* **AssignNPID (#ParticipantManagement)** Assign an identity to a node operator associating key information regarding its ownership, the jurisdiction in which it is located, and other information. The node operator is stored as a record in the registry. It contains the remaining node allowance for that node operator, that is the number of nodes the node operator can still add to the IC. When an additional node is added by the node operator, the remaining allowance is decreased.

* **RootUpgrade (#NetworkCanisterManagement)** A proposal to upgrade the root canister in the NNS subnetwork. The proposal is processed by the Lifeline canister, which controls the root canister. The proposal updates the Wasm module as well as the authorization settings.

* **SetICPSDR (#ExchangeRate)** Instruct the NNS about the market value of 1 ICP as measured by an IMF SDR. This setting affects cycles pricing (as the value of cycles shall be constant with respect to IMF SDRs).

* **UpgradeSubnetToReplicaVersion (#SubnetManagement)** Update the replica version running on a given subnet. The proposal changes the replica version that is used on the specified subnet. The version must be contained in the list of blessed replica versions. The upgrade is performed when the subnet creates the next regular CUP.

* **ClearProvisionalWhitelist (#NetworkEconomics)** Clears the provisional whitelist, which allows the listed principals to create canisters with cycles. The mechanism is only needed for bootstrap and testing and must be deactivated afterward.

* **RemoveNodeFromSubnet (#SubnetManagement)** Remove a node from a subnet. It then becomes available for reassignment. The execution of this proposal changes an existing subnet record to remove a node. From the perspective of the NNS, this update is a simple update of the subnet record in the registry.

* **SetAuthorizedSubnetworks (#Governance)** Informs the cycles minting canister that a certain principal is authorized to use certain subnetworks (from a list). Can also be used to set the â€œdefaultâ€ list of subnetworks that principals without special authorization are allowed to use.

* **SetFirewallConfig (#SubnetManagement)** Change the Firewall configuration in the registry (configures which boundary nodes subnet blockchain replicas will communicate with).

* **UpdateNodeOperatorConfig (#NodeAdmin)** Change a node operatorâ€™s allowance in the registry.

* **StopOrStartNNSCanister (#NetworkCanisterManagement)** Stop or start an NNS canister.

## ICP tokens

ICP are native utility tokens that play three key roles in the network:

1. **Facilitating Network Governance** ICP tokens can be locked to create neurons that participate in network governance by voting, through which they can earn economic rewards.

1. **Production of Cycles for Compute** ICP provides a source store of value that can be converted into â€œcycles,â€ which power computation in the role of fuel that is burned when it is used. The NNS converts ICP to cycles at a variable rate, so chosen to ensure users of the network can always create new cycles at approximately constant cost in real terms, such that the cost of acquiring fuel is predictable.

1. **Rewarding Participants** The network mints new ICP to reward and incentivize those playing important roles that enable the network to function, including: a) the provision of â€œvoting rewardsâ€ to those participating in governance, and b) the provision of â€œnode provider rewardsâ€ to those operating the node machines that are hosting the network.

## Ledger

The ICP ledger is hosted within the NNS, and records all balances of ICP in the manner of a spreadsheet. Each row is called an â€œaccount,â€ which has two fields (i.e., there are two â€œcolumnsâ€):

1. **Account identifier (bytes)** A unique value that is derived from the identity of the â€œprincipalâ€ that â€œcontrolsâ€ the account. Currently, the principal must either be: (i) the owner of a public key pair, or (ii) a canister smart contract that is part of the NNS. Account identifiers are derived by hashing the concatenation of a domain separator, the principal ID, and the subaccount (or zeros if no subaccount is given).

1. **Balance** (positive integer, representing one hundredth of a millionth of an ICP) The quantity of ICP assigned to the principal of the account.

When the principal is a public key or Canister, they can apply the following operation to an account:

1. **Send** Send a portion of the ICP balance to another account. If all the ICP is sent to another account, then the sending account ceases to exist (i.e., is deleted from the ledger).
2. **Notify** When the destination of the funds sent is the account of an NNS canister (e.g., an account of the governance canister), the sender can ask the ledger to notify the recipient canister of the incoming transfer. The recipient canister can then act on this notification. Two examples where this ability is used are creating a neuron and refreshing the stake of a neuron. These are detailed below.

Operations that require interaction between the ledger and the governance system (Neurons):

1. **Create neuron** When the principal is a public key holder, they may lock a portion of their balance inside a new neuron. Technically, creating the neuron is done in two stages. First transfer the ICP to be staked to an account of the governance canister (which corresponds to a new neuron â€” the details of the association are omitted here). Then notify the governance canister of the incoming transfer which updates its internal neuron bookkeeping. If the entire balance is locked inside a new neuron, the account ceases to exist (i.e., is deleted from the ledger). To move these ICP to a different account, such as back to the original account, where they can once again be controlled like a normal balance, the associated neuron must be fully dissolved and disbursed (destroyed). The new neuron that has been created is controlled by the private key of the principal that created it.
2. **Refresh stake** The stake of a neuron may be increased by transferring to its address/account in the ledger and notifying the governance canister of the incoming transfer. Refreshing the stake will change the maturity and age of the neuron prorated. For example, if the stake is doubled, the maturity and age will be halved, so spawning will yield the same amount and the age bonus will be the same as before (in absolute terms).

## Neurons

A neuron locks a balance of ICP and enables its owner to participate in network governance, through which they can earn rewards.

### Attributes

Neurons have the following attributes:

* **Identity (uint64)** The general identity of the neuron object. When a neuron is configured to follow another neuron, this is the value that is used. This is a random 64-bit value selected at neuron creation.

* **Account (bytes, private)** The ledger account where the locked ICP balance resides.

* **Controller (principal ID, private)** The principal that actually controls the neuron. The principal must identify a public key pair, which acts as a â€œmaster key,â€ such that the corresponding secret key should be kept very secure. The principal might control many neurons.

* **Hot Keys (list of principal ID, private)** Keys that can be used to perform actions with limited privileges, such as voting, without exposing the secret key corresponding to the principal (e.g., could be a WebAuthn key).

* **CreatedAt (timestamp)** When the Neuron was created.

* **AgingSince (timestamp)** The timestamp corresponding to the time this neuron has started aging. This is either the creation time or the last time at which the neuron has stopped dissolving. This value is meaningless when the neuron is dissolving, since a dissolving neuron always has an age of zero.

* DissolveState

     

    At any time, at most one of WhenDissolved and DissolveDelay are specified.

    * WhenDissolved (timestamp)

When the dissolve timer is running, this stores the timestamp in seconds from the Unix epoch, at which point the neuron becomes dissolved. At any time while the neuron is dissolving, the neuron owner may pause dissolving, in which case DissolveDelay will get assigned to: WhenDissolved minus the timestamp when the action is taken.

* * DissolveDelay (duration)

When the dissolve timer is stopped, this stores how much time the dissolve timer will be started with. It can be eight years at most. At any time while in this state, the neuron owner may (re)start dissolving, in which case WhenDissolved will get assigned to the timestamp when the action is taken plus DissolveDelay.

* **Maturity (positive number )** The maturity of a neuron which reflects the amount of voting rewards allocated to a neuron. When new neurons are created, their maturity is zero. When neurons vote, over time the NNS increases their maturity to reward them.

* **Follow Relationships (mapping from topic to list of followees, private)** A neuron can be configured to vote automatically by following other neurons on a topic-by-topic basis. For any valid topic, a list of followees can be specified, and the neuron will follow the vote of a majority of the followees on a proposal with a type belonging to that topic. If a null topic is specified, this acts as a catch-all that enables the neuron to follow the vote of followees where a rule has not been specified.

* **Recent Votes (public)** A record of recent votes is maintained. This can provide a guide for those wishing to evaluate whether to follow a neuron, or how their followees are voting.

* **NotForProfit (boolean)** Whether this neuron is â€œnot for profit,â€ making it dissolvable by voting.

The following attributes can be computed:

* **Age (seconds)** (computed from AgingSince and current time) The period of time that has elapsed since the neuron was created or last stopped dissolving. Conceptually, whenever a neuron starts dissolving, then its age is reset to zero and remains zero while it is dissolving. If a dissolving neuron has dissolving turned off, the current time becomes the effective neuron creation date for the purposes of calculating the age.

* State (LOCKED or DISSOLVING or DISSOLVED)

     

    (computed from DissolveState and the current time)

    * LOCKED: In this state, the neuron is locked with a specific DissolveDelay. It accrues age by the passage of time and it can vote if DissolveDelay is at least six months. The method start_dissolving can be called to transfer the neuron to the DISSOLVING state. The method increase_dissolve_delay can be used to increase the dissolve delay without affecting the state or the age of the neuron.
    * DISSOLVING: In this state, the neuronâ€™s effective dissolve delay decreases with the passage of time. While dissolving, the neuronâ€™s age is considered zero. Eventually it will reach the DISSOLVED state. The method stop_dissolving can be called to transfer the neuron to the LOCKED state, and the neuron will start aging again. The method increase_dissolve_delay can be used to increase the dissolve delay, but this will not stop the timer or affect the age of the neuron.
    * DISSOLVED: In the dissolved state, the neuronâ€™s stake can be disbursed using the disburse method. It cannot vote as its dissolve delay is considered to be zero. If the method increase_dissolve_delay is called in this state, the neuron will become locked with the specified dissolve delay and start aging again. Neuron holders have an incentive not to keep neurons in the dissolved state for a long time: if the holders want to make their tokens liquid, they disburse the neuronâ€™s stake, and if they want to earn voting rewards, they increase the dissolve delay. If these incentives turn out to be insufficient, the NNS may decide to impose further restrictions on dissolved neurons.

* **ControlByProposals (boolean)** (true if the neuron has a non-empty list of followees on the #NeuronManagement topic) If a neuron specifies followees on the ManageNeuron topic, it can be managed by proposals of type ManageNeuron (#NeuronManagement), which may only be voted upon by the neuronâ€™s own followees. This provides a foundation for the management of highly security sensitive neurons, since it allows them to be maintained without hot keys or the secret key of the principal, which can be kept in cold storage or even destroyed (so long as the associated balance of ICP need never be unlocked). For example, the DFINITY Foundation or the Internet Computer Association might publicize the address of special neurons that will be made to vote according to their wishes, so that others can configure their neurons to follow them and leverage their expertise and efforts in governance. One problem with such practices is that they introduce the risk that secret keys used in the management of the publicized neurons might be compromised, allowing hackers to take control and â€œtrickâ€ large numbers of following neurons into voting according to their wishes. If the publicized neurons have admin proposals enabled, however, then they can be administered by the neurons they follow (their followees), which are typically controlled by a large number of team members who cannot be simultaneously extorted, without any need for the usage of secret keys whatsoever.

### Commands

The principal that controls a neuron may instruct it to perform the following actions:

* **Start Dissolving** The dissolve delay is like a kitchen timer that can only be turned in one direction. It can be arbitrarily increased, but only reduced by turning on dissolve mode and counting down. The neuron can be instructed to start â€œdissolving.â€ When the neuron is dissolving, its dissolve delay falls over the passage of time until either it is stopped or it reaches zero. A neuron cannot vote (or earn rewards for voting) when its dissolve delay falls below six months. Once the dissolve delay reaches zero, it stops falling and the controlling principal can instruct the neuron to disburse.

* **Stop Dissolving** A neuron that is dissolving can be instructed to stop, whereupon its dissolve delay stops falling with time.

* **Disburse** When the dissolve delay of the neuron is 0, its controlling principal can instruct it to disburse the neuronâ€™s stake. Its locked ICP balance is transferred to a specified new ledger account, and the neuron and its own ledger account disappear.

* **Increase Dissolve Delay** The dissolve delay of a neuron can be increased up to a maximum of eight years.

* **Spawn** When the maturity of a neuron has risen above a threshold, it can be instructed to spawn a new neuron. This creates a new neuron that locks a new balance of ICP on the ledger. The new neuron can remain controlled by the same principal as its parent, or be assigned to a new principal. When a neuron spawns a new neuron, its maturity falls to zero.

* **Add Hot Key** Add a new hot key that can be used to manage the neuron. This provides an alternative to using the principalâ€™s cold key to manage the neuron, which might be onerous and difficult to keep secure, especially if it is used regularly. A hot key might be a WebAuthn key that is maintained inside a user device, such as a smartphone.

* **Remove Hot Key** Remove a hot key that has been previously assigned to the neuron.

The following actions can be initiated using the principal or a hot key that has been configured:

* **Vote** Have the neuron vote to either adopt or reject a proposal with a specified ID.
* **Follow** Add a rule that enables the neuron to vote automatically on proposals that belong to a specific topic, by specifying a group of followee neurons whose majority vote is followed. The configuration of such follow rules can be used to: a) distribute control over voting power amongst multiple entities, b) have a neuron vote automatically when its owner lacks time to evaluate newly submitted proposals, c) have a neuron vote automatically when its own lacks the expertise to evaluate newly submitted proposals, and d) for other purposes. A follow rule specifies a set of followees. Once a majority of the followees votes to adopt or reject a proposal belonging to the specified topic, the neuron votes the same way. If it becomes impossible for a majority of the followees to adopt (for example, because they are split 50â€“50 between adopt and reject), then the neuron votes to reject. If a rule is specified where the proposal topic is null, then it becomes a catch-all follow rule, which will be used to vote automatically on proposals belonging to topics for which no specific rule has been specified. If the list of followees is empty, this effectively removes a follow rule.



# Governance of the Internet Computer

The Internet Computer blockchain is governed by the [Network Nervous System](https://wiki.internetcomputer.org/wiki/Network_Nervous_System) (NNS) [[1\]](https://wiki.internetcomputer.org/wiki/Governance_of_the_Internet_Computer#cite_note-1). The NNS is an algorithmic governance system that oversees the network and the token economics that make it possible to build DeFi dapps, open internet services and enterprise systems.

Holders of the Internet Computerâ€™s [ICP utility tokens](https://wiki.internetcomputer.org/wiki/ICP_Tokenomics) can lock their tokens in [neurons](https://wiki.internetcomputer.org/wiki/Neurons_101) to participate in governance and contribute to decision-making, such as voting to determine whether or not a new collection of nodes (also called a subnet) should be added to the network.

### Why the Internet Computer needs a Network Nervous System[[2\]](https://wiki.internetcomputer.org/wiki/Governance_of_the_Internet_Computer#cite_note-2)

The Internet Computer is a distributed protocol run by a [network of node machines](https://wiki.internetcomputer.org/wiki/Sovereign_Network), which are hosted in different data centers. The nodes communicate with one another over the internet to achieve a [consensus](https://wiki.internetcomputer.org/wiki/Proof_of_Useful_Work) on what the Internet Computerâ€™s state should be. A collection of nodes engaging in consensus is called a subnet. On top of this underlying communication and consensus protocol, the Internet Computer hosts [Canister Smart Contracts](https://wiki.internetcomputer.org/w/index.php?title=Canister_Smart_Contracts&action=edit&redlink=1) called *canisters*, which are stateful programs that can also communicate with each other. The state of all of the canisters has to be replicated across all of the nodes. Therefore, to allow the Internet Computer to scale indefinitely, the network is made up of not just one subnet, but multiple subnets.

Different [subnets](https://wiki.internetcomputer.org/wiki/Subnet_blockchain) can communicate with one another, enabling [Canister Smart Contracts](https://wiki.internetcomputer.org/w/index.php?title=Canister_Smart_Contracts&action=edit&redlink=1) that are hosted on different subnets to also communicate with each other. For the Internet Computer to scale on-demand, the network must be able to add new subnets over time to increase compute capacity. Moreover, the robustness of the subnets can be improved by adding new nodes to them over time. Eventually, the Internet Computer will run millions of nodes at scale. This means that there needs to be a mechanism by which the nodes and subnets are organized, tracked, and managed. For example, decisions must be made about when subnets and nodes should be added or removed. In addition, the Internet Computer was launched with an initial feature set, which evolves over time. Therefore, the Internet Computer needs to be able to make decisions on how to evolve the protocol in a distributed manner.



# NNS Canisters

The Network Nervous System of the Internet Computer is realized by a set of *[canisters](https://wiki.internetcomputer.org/wiki/Glossary#canister)*. NNS canisters include:

1. **Ledger canister:** The ledger canister stores the ICP utility *token balance* of each principal and the history of ICP *transactions*.
2. **Governance canister:** The governance canister receives and stores *Proposals*, which are suggestions for how the Internet Computer should be changed. These proposals can then be voted on. The governance canister also tracks *Neurons*, which determine who is allowed to participate in governance.
3. **Registry canister:** The registry canister stores the configuration of the whole Internet Computer, e.g., which nodes belong to a certain subnet and the software each node should run.
4. **Cycles minting canister**: This canister is responsible for minting *cycles*, the fuel for canisters for computation, communication and storage. New cycles can be minted when a new canister is newly created or when an existing canister is topped up with additional cycles.
5. **Root canister**: The root canister is the controller of all other NNS canisters and responsible for upgrading them.
6. **Lifeline canister**: The lifeline canister is the controller of the root canister and responsible for upgrading it.
7. **Archive canisters**: The canisters that store the history of the ledger transactions once there are too many transactions to keep in a single canister.
8. **Genesis token canister:** This is the canister that was used to initialize the neurons that already existed during genesis.

The canisters that users of the Internet Computer are interacting with the most are the first two: the ledger canister for making transactions, and the governance canister for staking tokens and submitting and voting on proposals.

## Ledger canister & ICP utility tokens in the NNS

[ICP utility tokens](https://wiki.internetcomputer.org/wiki/ICP_token) are managed by the ledger canister, which stores two things: accounts and transactions. An account record keeps track of how many tokens are in the possession of a given [principal](https://wiki.internetcomputer.org/wiki/Principal) (i.e., an identity by which a user is authenticated on the Internet Computer). Tokens can then be sent from one account to another, and this is recorded in the transactions of the ledger canister.

In the NNS, ICP utility tokens are used for three different things:

1. ICP tokens facilitate **participation in governance** (more below on how the neurons are connected with the tokens).
2. Those who participate in governance and those who provide compute capacity by operating note machines are **rewarded** in ICP tokens.
3. ICP tokens are used for **conversion into cycles**, which are fuel for canisters for computation, communication and storage.

## Governance Canister

The governance canister is responsible for holding *neurons*, determining who is allowed to participate in governance. Moreover, it stores proposals, which are suggestions for changes to the Internet Computer, and the information associated with proposals that decides if these suggestions should be implemented. If a proposal is adopted, the governance canister automatically executes the decision. Finally, the governance canister distributes rewards to those neurons who participated in voting and contributed to the decision making.

## Neurons

Neurons contain *locked* ICP utility tokens. These staked tokens are not liquid and cannot be transferred freely to others.

### Neuron Attributes

Each neuron stores a number of neuron attributes. Some of the most important ones are the following:

* How many ICP tokens are *locked* in the neuron. This information is accessible both by a neuron referencing an account on the ledger canister that stores the neuron's balance and by a cached stake on the governance canister.
* A *controller* principal, which identifies who manages the neuron's actions.
* A unique *neuron ID*
* The neuron's *dissolve delay.* Intuitively, the dissolve delay defines the earliest time when the locked ICP tokens can be unlocked. This time can be increased to up to 8 years but it can only be decreased by waiting for time to pass. A neuron can either be *non-dissolving*, *dissolving*, or *dissolved.* If a neuron is non-dissolving, its set dissolve delay is kept stable and the timer is not running down. The neuron can then be set to dissolving, which means that the dissolve delay is decreasing with the time. Finally, if a the dissolve delay reaches 0, the neuron is dissolved and the locked tokens can be transferred out of the neuron.
* The *age*, which is between 0 and 4 years. A neuron's age determines the time since when then neuron has last entered the non-dissolving state.

A neuron's dissolve delay determines a neuron's *eligibility* to participate in voting. Namely, only those neurons with tokens locked for at least six months are eligible to participate in governance. This incentivizes neuron holders to vote such that the value of their tokens is maximized for a future date. Assuming the value of the tokens is a rough proxy for the networkâ€™s success, this incentivizes neuron holders to vote in the long-term interest of the Internet Computer.

A neuron's *voting power* depends on how many tokens a neuron has locked, as well as the neuron's dissolve delay and age. Intuitively, those who are more committed to the Internet Computer, as they have locked their tokens for longer or have already staked them for a long time, have more voting power. The voting power increases with the dissolve delay and the age.

Finally, the number of rewards that each neuron receives depends on the number of votes that the neuron participated in as well as the neuron's voting power.

### How to lock tokens in a neuron[[1\]](https://wiki.internetcomputer.org/wiki/NNS_Canisters#cite_note-1)

As a user, there are different [ICP staking options](https://wiki.internetcomputer.org/wiki/ICP_staking_options) to stake ICP utility tokens in a neuron. The effect of such an operation is that these ICP tokens are transferred to a ledger account that is associated with a newly created neuron. The tokens are thus locked and cannot be used freely by the neuron holder.

**Example.** *Letâ€™s assume that User B, who has an account (A1) on the ledger canister, would like to lock a hundred tokens in a neuron. To do so, User B sends a command to the NNS specifying the number of tokens and User Bâ€™s corresponding principal ID.*

*A transaction is then recorded on the ledger, which specifies that some tokens are sent from the original account (A1) of the user to a new account (A2), which also creates the new account (A2) that holds the locked tokens. A new neuron is created in the governance canister that specifies that User B is the one controlling this neuron and that specifies that the amount of locked tokens is defined by the new ledger account A2.*

*Externally, itâ€™s not visible that the new account (A2) holds locked tokens or is in any way related to the original account (A1). Nevertheless, this account is in fact controlled by the neuron, which means that the tokens are not liquid and that User B cannot transfer the tokens or convert the tokens into cycles.*

The main reason for a user to lock tokens in a neuron is to be able to participate in voting and get voting rewards. Both are described in more detail below.

## Proposals

A proposal is a suggestion for a change to the Internet Computer. More technically, a proposal describes a *method* in a canister that is called if the proposal is accepted. Moreover, it describes the *parameters* with which the method will be called.

The Internet Computer supports a variety of different proposal *topics*. Here are some examples of topics that are supported in the NNS governance canister:

* \#SubnetManagement Proposals: This considers topology changes. The example proposal above about whether a node should be added to a subnet falls into this category.
* \#NodeAdmin Proposals: This concerns the administration of node machines. An example of a proposal could specify that all of the nodes in a subnet should be updated.
* \#NetworkEconomics Proposals: This concerns the administration of network economics. For example: what rewards should be paid to the node machine providers?
    1. Motion Proposals: These proposals do not have a direct execution of a method as a consequence but are merely there to record the opinion of the community on a specified matter.

## Voting and proposal lifecycle

### Submitting a proposal

Any eligible neuron can make and [submit a proposal](https://wiki.internetcomputer.org/index.php?title=Neuron_Attributes_and_Commands#Make_Proposal). To avoid being inundated by useless proposals, a user submitting a proposal has to pay a fee of 1 ICP when submitting a proposal, that they will receive back if the proposal is adopted (but that they will not receive back if the proposal is rejected).

**Example.** *Letâ€™s consider a User C who would like to suggest that a new subnet is created that initially consists of two nodes: Node 1 and Node 2. Once User C controls a neuron, they can submit a proposal by specifying their neuron ID, the type of proposal that they would like to submit, and the proposalâ€™s parameters. In our example, the proposal specifies that a new subnet should be created and the proposal's parameters consist of the initial nodes Node 1 and Node 2. Upon the receipt of this proposal, the governance canister first checks that this user is indeed the one controlling the neuron with the given ID and that this neuron is eligible to vote. If the requirements are met, the proposal is added to the governance canister.*

After a proposal is submitted by an eligible neuron, the proposal is created and stored in the governance canister. Moreover, the governance canister computes and stores additional information with each proposal. First, the [voting power](https://wiki.internetcomputer.org/w/index.php?title=Voting_power&action=edit&redlink=1) of each neuron is computed and stored together with the proposal. The sum of all of these voting powers also determines the *total voting power* associated with a given proposal.

When a new proposal is created, the number of â€œyesâ€ votes associated with the proposal is already increased by the proposerâ€™s voting power. This reflects that the proposal already has the support of the user submitting it.

Moreover, each proposal has an associated *voting period,* which determines the period of time over which votes for this proposal are accepted.

### Viewing NNS Proposals

You can see all the NNS proposals on the Internet Computer dashboard: https://dashboard.internetcomputer.org/governance

### Discussing NNS Proposals

Voters can freely discuss proposal anywhere they like. A lot of NNS proposals are discussed on the developer forum: https://forum.dfinity.org/c/roadmap/29.

### Voting on a proposal

After a proposal is submitted and added to the governance canister, other users who control neurons can [vote on the proposal](https://wiki.internetcomputer.org/wiki/ICP_voting_options). Currently, the most user-friendly way to vote on NNS proposals is via the NNS Frontend dapp: https://nns.ic0.app/. For voting, users would first learn which are the open proposals on the governance canister that they can actually vote on. This information is available, for example on Internet Computer dashboard: https://dashboard.internetcomputer.org/governance or in the [NNS frontend dapp](https://wiki.internetcomputer.org/w/index.php?title=NNS_frontend_dapp&action=edit&redlink=1).

If a neuron votes in favor of a proposal, the governance canister adds this neuronâ€™s voting power, as stored with the proposal, to the â€œYesâ€-votes associated with the proposal. Likewise, if a neuron votes against a proposal, the governance canister adds the neuronâ€™s voting power to the â€œNoâ€-votes of the proposal.

**Example.** *Assume that a given User D would like to reject the proposal that was just added by User C. To do so, User D would send their neuron ID and a â€œnoâ€ vote to the governance canister. The governance canister would check that the vote is coming from the correct user who controls the neuron and confirm that the neuron is eligible to vote. If the conditions are met, the governance canister would then add the voting power of User D to the â€œnoâ€ votes.*

#### Neuron following and liquid democracy

Users may not have the time or knowledge to participate in all voting decisions. Therefore, instead of directly voting on proposals, neuron holders may choose to delegate their vote to other neurons that they trust with certain decisions. This concept of delegating the right to vote to other voters who then effectively vote with more voting power is called *liquid democracy.*

Concretely, for each proposal topic a neuron can [specify a set of other neurons that it would like to *follow*](https://wiki.internetcomputer.org/w/index.php?title=How_to_follow_neurons&action=edit&redlink=1) *(so-called followees)*. In addition, a neuron can specify a set of followees for "all other topics" that are not covered by specific rules. The governance canister keeps track of this relation of follower and followee neurons. It then automatically casts a vote for a follower neuron based on the decision of the followees. In particular, if more than 50% of the followees vote "yes", then a "yes" vote is cast for the follower and if at least 50% of the followees vote "no", then a "no" vote is cast for the follower.

**Example**. *Consider neuron N1 that follows the set of neurons {N2, N3, N4, N5} on all proposal topics. Consider now that a proposal is submitted by another neuron N6. Assume in a first scenario that first N2 votes "No" and then N3 votes "No" on the proposal. In that case, the governance canister will also send a "No" vote for N1 two out of four followees voted "No" (which also means that it is not possible anymore to get more than 50% "Yes" votes). Assume a second scenario where N2 votes "Yes" and then N3 votes "Yes" on the proposal. In that case, no vote is sent yet for N1. However, if either N4 and N5 also send a "Yes" vote, a "Yes" vote is also cast for N1.*

This liquid democracy has great advantages. First, it allows even neurons that do not have enough knowledge of a certain topic to nevertheless participate in governance by choosing the neurons that they trust with certain decisions and by delegating their vote to them. In particular, a neuron can choose a different set of followees for different topics. Moreover, this mechanism allows neuron holders to get voting rewards from voting participation even if they do not have time to actively participate in all voting decision.

### Proposal decision and wait-for-quiet

A proposal can be *decided* in two ways:

1. **Absolute Majority before the voting period ends**: At any point, even before the voting period ends, if an absolute majority (more than half of the total voting power stored in the proposal) has voted Yes, then the proposal is adopted and if an absolute majority has voted No, then the proposal is rejected.
2. **Simple Majority at the voting periodâ€™s end**: When the voting period ends, if a simple majority (more than half of the cast votes) has voted Yes and the number of these Yes-votes constitute at least 3% of the total voting power, then the proposal is adopted. Otherwise, the proposal is rejected.

What also plays into this is the fact that the governance voting algorithm also applies *wait-for-quiet*. The idea of wait-for-quiet is to decide proposals quickly when all voters agree, but increase the time that neurons can vote for proposals that are controversial. That means that the voting period can be dynamically increased, depending on the neuronsâ€™ votes. In particular, each time a proposalâ€™s outcome is turned (either a Yes-majority is turned to a No-majority or vice versa), the proposalâ€™s deadline is increased. Currently, a proposal's initial voting period is 4 days and can be increased by at most another 4 days. That is, the voting period that is taken into account for the above rules can be between 4 and 8 days, depending on the voting activity.

### Proposal execution

Recall that a proposal defines a method, a canister, and some parameters. As soon as a proposal is adopted, the defined method on the specified canister is called with the given parameters. This is done fully automatically by the governance canister.

## Voting Rewards

Contributing to decision-making is one incentive for voters to lock their neurons, but they are also *rewarded* for participating in network governance.

Specifically, each day the governance canister considers which proposal can be settled. It is then considered for each neuron in how many proposals they participated and with which voting power. Depending on this, the neurons get rewarded. Concretely, rewards are added to the neuron's attribute that is called *maturity.*

A neuron holder can then profit from the maturity in two ways:

1. **Spawn maturity:** A neuron holder can choose to [spawn a new neuron](https://wiki.internetcomputer.org/w/index.php?title=How_to_spawn_a_neuron&action=edit&redlink=1) to get liquid ICP utility tokens worth the voting rewards. Spawning a new neuron has the effect that a new neuron with a new associated account on the ledger will be created, which contains the amount of staked ICP utility token equivalent to the maturity of the original neuron. In fact, the new tokens are minted and transferred to the new account, which is also recorded in the ledger canister. The new neuron has a small dissolve delay of 7 days. This means that users only need to wait a short amount of time to be able to unlock the tokens and use them freely, no matter what dissolve delay the original neuron has.
2. **Stake maturity**: A user can stake maturity which locks the maturity until the neuron is dissolved. Once a neuron is dissolved, staked maturity is unlocked and becomes normal maturity. Staked maturity contributes to the voting power of the neuron as determined by Voting Power = (ICP staked + maturity staked) x Dissolve Delay Bonus x Age Bonus. No ICP is (or can be) produced from staked maturity until the neuron is dissolved and the maturity is spawned (as described in the section above), at which point it is subject to maturity modulation.

## Cycles Minting Canister and Cycles[[2\]](https://wiki.internetcomputer.org/wiki/NNS_Canisters#cite_note-2)

Besides governance participation and voting rewards, tokens can also be converted into cycles, which fuel computation and storage on the Internet Computer. Each canister on the Internet Computer, except for those on the NNS, uses cycles for computations and has some cycles stored within it. While the token price may vary over time, the goal of the cycles is to keep the price of computation roughly consistent over time.

The canister responsible for converting ICP utility tokens into cycles is the *Cycles Minting Canister.* To convert cycles for creating or topping-up a canister, a user needs to send ICP utility tokens to the Cycles Minting Canister. This canister then burns the tokens and mints the cycles.

The Cycles Minting Canister only facilitates the conversion of ICP utility tokens to cycles but not the other way around. Cycles are burned in canisters when they use computation and storage over time.

**Example.** *Consider User E who runs a canister on the Internet Computer and would like to top up the cycles of this canister so that it can perform even more computations. Also assume that this canister currently has 700 trillion cycles and User E would like to increase this number by 200 trillion. To do so, the user would send a command to the NNS that specifies the action of topping up their canister. Upon receiving this command, a transaction is made from the userâ€™s account to the Cycles Minting Canister. As a result of this transaction, the Cycles Minting Canister would burn the tokens, mint new cycles, and send these freshly minted cycles to the userâ€™s canister, meaning the canister balance is now 900 trillion cycles.*



ICP Tokenomics
(Redirected from ICP token)
Introduction
ICP tokenomics encompasses aspects such as ICP token supply, distribution, use cases, and mechanisms to maintain stability of the ICP network and drive DAO participation.

By establishing a well-designed token economy, ICP project aim to create sustainable ecosystems that encourage participation, growth, and reliability for ICP smart contracts, developers, DAO participants, node providers, and dapp users.

Design Intent
The design intent of the tokenomics of the IC is to create a self-sustaining ecosystem that can balance the following goals and constraints:

Developers pay very low & stable storage and compute costs.
Node provider rewards are high enough to incentivize node providers to be part of the network.
Voting rewards are balanced to encourage staking and governance participation while also limiting inflation
Since this is a dynamic system, it is up to the community to keep an eye on the system and adjust its levers accordingly, evolving and optimizing the IC's tokenomics via NNS proposals.

Uses of ICP token
It is important to understand a bit about the Tokenomics of ICP. ICP is the utility token of ICP blockchain. The following are the core use cases that outline how the ICP token helps in the functioning of the Internet Computer blockchain.

1. Node Provider Rewards
The node providers that offer compute/storage infrastructure to the Internet Computer blockchain receive ICP rewards. Each node receives a flat monthly reward calculated in fiat and paid in the form of ICP tokens. This model ensures that the cost that the network bears for running a node is always constant in fiat terms. The reward varies slightly based on the geographical location of the node to ensure the IC is able to achieve a wider geographical distribution of nodes. Each node provider continues to receive rewards as long as they guarantee the right quality of service. The rewards are paid by minting new ICP tokens, causing inflation.

See also:

Node Provider Remuneration
2. Governance:
ICP token holder can stake (lock) their tokens to create Neurons. Holding neurons enables them to secure voting rights via the ICâ€™s on-chain open governance system, the Network Nervous System (NNS). The NNS enables the neuron holders (people staking ICP) to vote on proposals related to aspects like upgrading the IC protocol and software running on node machines, onboarding new node providers, adding node machines into the blockchain network, and creating new subnet blockchains to increase capacity. The NNS implements liquid democracy: neurons can follow other neurons a delegate voting power. The neuron holders receive rewards from the IC protocol for participating in the voting process and helping with the governance. Rewards are distributed in the form of maturity which is an attribute of a neuron. Neurons holders can convert maturity to ICP at a later stage. This process is subject to maturity modulation.

See also:

Governance of the Internet Computer
Staking, voting and rewards
Tutorials for acquiring, managing, and staking ICP
3. Fuel for Computation/Storage
Canister smart contract computations running on the Internet Computer blockchain are fueled by â€œcyclesâ€. These cycles are derived by burning ICP tokens. The cycles play a similar role to â€œgasâ€ on Ethereum. There are several major differences, however. One of the most fundamental differences is that Ethereum leverages â€œuser paysâ€ while the Internet Computer has â€œsmart contract paysâ€ model (sometimes called â€œreverse gasâ€) model. Whereas the Ethereum blockchain requires end-users to send payments for the gas that smart contracts consume with every transaction, on the Internet Computer, Canister smart contracts are pre-charged with cycles, such that contracts effectively pay for their own computation - freeing users from the responsibility. Cycles are generated by burning ICP utility tokens, causing deflation.

4. Transaction/Proposal Fees
When any ICP holder transfers their ICP from one wallet to another they incur a small transaction fee paid in ICP. Additionally, ICP holders pay a small fee while submitting new proposals to the NNS.

Token Supply
The total supply of ICP is variable, with both minting (inflationary) and burning (deflationary) mechanisms. See: Total supply, circulating supply, and staked ICP.

To summarize, ICP inflation happens for rewarding node providers and governance participants while deflation happens when ICP is burnt for computation or for transaction/proposal submission fees.

How to get ICP tokens
There are different ways you can acquire ICP tokens:

Purchase ICP tokens directly through an exchange that lists ICP tokens available for trade. Coinmarketcap maintains a reasonably complete list of exchanges that trade ICP tokens
Receive tokens as voting rewards for participating in the governance of the Internet Computer
Receive ICP tokens from somebody who sends them to an account you created
Receive a developer grant of tokens through the Internet Computer Association (ICA) or the DFINITY Foundation
Receive tokens as remuneration for providing computing capacity as a node provider
Key tokenomics concepts
Maturity
neurons
Tokenomics series
The Tokenomics Series are a series of articles by the DFINITY Foundation presenting an ICP tokenomics framework that enables the community to analyze the relationship between various factors influencing the supply and demand of ICP. This framework will offer a quantitative basis for assessing the state of ICP tokenomics over time and evaluating potential changes.

May 11, 2023 - Projection of cycle demand and required network capacity of the IC
May 24, 2023 - Projecting total supply of ICP



# Total supply, circulating supply, and staked ICP

For a crypto community to understand the [governance](https://wiki.internetcomputer.org/wiki/Governance_of_the_Internet_Computer) and [tokenomics](https://wiki.internetcomputer.org/wiki/ICP_Tokenomics) of ICP, understanding the supply of ICP is important.

## Definitions

### Total supply

Total supply is the sum of all tokens currently in the system (whether they are locked/staked or not).

The total supply changes over time due to inflation and deflation. Its current value can be seen on the [IC Circulation page](https://dashboard.internetcomputer.org/circulation) of the IC dashboard.

### Circulating supply

The circulating supply is all tokens except liquid (non-staked) tokens owned by the DFINITY Foundation. The circulating supply definition was updated to its current definition on 18APR23 through an approved vote by the NNS on [proposal 117360.](https://dashboard.internetcomputer.org/proposal/117360)

The current circulating supply can be seen on the [IC Circulation page](https://dashboard.internetcomputer.org/circulation) of the IC dashboard.

### Staked ICP

Staked ICP supply is the sum of all the tokens that are locked or dissolving in neurons at any given time that are earning rewards. At this time, there is a minimum lockup period of 6 months to accrue voting rewards.

The total amount of staked ICP changes over time. Its current value can be seen on the [Neurons page](https://dashboard.internetcomputer.org/neurons) of the IC dashboard.

## Numbers

### At network Genesis

May 10, 2021:

* Total supply: 469 million
* Circulating supply: 123 million

### Current status

As of September 14th, 2023:

* Total supply: 505.8 million ICP
* Circulating supply: 444.6 million (87.5% of total supply)
* Staked ICP: 251.8 million (49.8% of total supply).
    * 81.8% of ICP staked is staked with more than a 1-year dissolve delay
    * 52.8% of ICP staked is staked for an 8-year dissolve
    * One can see the breakdown of staked ICP by dissolve delays in [IC neuron dashboard](https://dashboard.internetcomputer.org/neurons).

* As outlined in the section above Circulating supply represents ICP that was ever liquid. A subset of the circulating supply is locked in neurons as staked ICP.

## Inflationary mechanisms

The NNS mints ICP tokens for two reasons:

* For voting rewards (Governance).
* For node provider rewards.

The amount of ICP minted since Genesis can be seen in the ["Total Rewards" chart](https://dashboard.internetcomputer.org/circulation) on the IC dashboard.

### Paying staking rewards

Voting rewards are generated by minting ICP, although this minting only happens at the moment rewards are spawned, maturity is merged, or the neuron is disbursed.

The voting rewards rate schedule is designed with the goal that 90% of the token supply is staked in neurons. With this goal in mind, in the first year, the NNS allocates 10% of the total supply to generate voting rewards. Note the term "allocates" rather than "mints", because rewards are not minted (increasing the total supply) until they are spawned, merged, or the neuron is disbursed.

As the network becomes more stable over time, this allocation rate drops quadratically until it reaches 5% by year 8. See chart below from the [IC Circulation page](https://dashboard.internetcomputer.org/circulation) on the IC dashboard.:

[![NNS minting % by year.png](https://mywikis-wiki-media.s3.us-central-1.wasabisys.com/internetcomputer/thumb/NNS_minting_%25_by_year.png/800px-NNS_minting_%25_by_year.png)](https://wiki.internetcomputer.org/wiki/File:NNS_minting_%_by_year.png)

**Like all parameters in the NNS, this rate schedule can be changed via NNS proposals.**

See more in [Staking, voting and rewards](https://wiki.internetcomputer.org/wiki/Staking,_voting_and_rewards).

### Node provider rewards

Node providers are rewarded for running the node machines that power the Internet Computer.

## Deflationary mechanisms

The NNS burns ICP tokens for three reasons:

* To mint cycles, used to pay for compute and storage.
* For transaction fees.
* For failed NNS proposal fees.

The amount of ICP burned since Genesis can be seen in the ["Total ICP Burned" chart](https://dashboard.internetcomputer.org/circulation) on the IC dashboard.

### Paying for compute and storage

Dapp and smart contract developers pay computation and storage costs with cycles. Cycles are acquired from the NNS by converting ICP to cycles, which burns the converted ICP.

The cycles costs for IC computation and storage can be seen at [Computation and Storage Costs](https://smartcontracts.org/docs/developers-guide/computation-and-storage-costs.html).

### Transaction fees

Transferring ICP across accounts incurs a transaction fee of 0.0001 ICP, which is burned.

### Failed NNS proposals

It costs 10 ICP to submit a proposal. If the proposal passes, the 10 ICP is returned to the proposer. If the proposal is rejected, the 10 ICP is burned. Note that this only happens at disbursement or merging of neurons, so accumulated failed proposal fees can persist for a while before finally contributing to deflation.

## Historical factors affecting circulating supply

The Internet Computer blockchain is a result of several years of unyielding R&D. By Genesis, the DFINITY foundation, a major contributor to the Internet Computer was over 200 full-time members. Over the past several years the foundation raised financing in three main rounds and also allocated ICP tokens to the community in the form of an airdrop event.

For a breakdown of the different rounds and vesting schedules, see Messari's report ["Introduction to ICP"](https://messari.io/article/an-introduction-to-dfinity-and-the-internet-computer?referrer=asset:internet-computer). The unlocking of neurons has been the **largest contributing factor** to circulating supply since Genesis, so it's important to understand the context.

1. **Seed Round, Feb-2017:** This round was advertised by a tweet and open to the public by downloading a web extension. DFINITY raised CHF3.9 million (US$3.9 million) from 370 participants, at a valuation of $16 million, or a price of $0.03 per token. It held a portion of these funds in ETH and BTC during the 2017 crypto bull run. Seed round participants received all of their tokens at genesis but are staked inside 49 neurons. Each neuron has a different dissolve delay counting from 0 to 49 months. So this is practically equivalent to a 49-month "vesting schedule" see [How to Access â€˜Seedâ€™ and â€˜Airdropâ€™ ICP Tokens and Participate in the Internet Computer Network](https://medium.com/dfinity/how-to-access-seed-and-airdrop-icp-tokens-and-participate-in-the-internet-computer-network-e6cd663a0c3c).
2. **Strategic Round, Jan-2018:** DFINITY raised $20.54 million for 7.00% of the initial supply (the number has been revised from the previously cited 6.84%). This allocation will vest monthly over three years starting from mainnet launch (May 2021). Participants include Polychain Capital, Andreessen Horowitz, CoinFund, Multicoin Capital, and Greycroft Partners. This round marks the first token a16z invested in. Polychain and DFINITY later collaborated to create the "DFINITY Ecosystem Venture Fund" (later renamed ["Beacon Fund"](https://dfinity.org/ecosystem/fund/)) of an undisclosed size. The goal is to fund new projects that would grow the IC's application ecosystem. The media reported that DFINITY raised a much larger amount of $61 million.
3. **Private Sale, Aug-2018:** 110 participants contributed $97 million for 4.96% of the initial supply, sold at 4 CHF (around $4 at the time) per ICP token. This number has been revised from 4.75% previously reported. This allocation came with a monthly vesting schedule of one year from mainnet launch. Vesting began one month after the initial token distribution event on May 10, 2021. Participants in this round include Andreessen Horowitz, Polychain Capital, SV Angel, Aspect Ventures, Electric Capital, ZeroEx, Scalar Capital, and Multicoin Capital.
4. **Airdrop, May-2018:** $35 million worth of ICP tokens (formerly DFN), or 0.80% of the initial supply, was airdropped to early supporters by being part of their mailing list, forums, and community. At this time, valuations reached $1.89 billion. Airdrop participants received the IOU version of their ICP tokens in September 2020. This allocation came with a monthly distribution schedule of one year from mainnet launch, which began on May 10, 2021.

## Conclusion

**Ultimately, the NNS is controlled by the community so it can vote to change any of the parameters. The parameters and mechanisms described are the current ones.**

The ICP token has a Total Supply of 505.8MM, Circulating Supply of 444.6MM as of August, 2023. 251.8MM ICP (49.8% of total supply) is staked by token holders in the form of neurons with over 81.8% locked for over 1 year.

The number of tokens is constantly changing. The rewards paid out to the node providers and governance participants contribute to the inflation in token supply while factors like compute/storage fees and transaction fees cause deflation in the total supply.