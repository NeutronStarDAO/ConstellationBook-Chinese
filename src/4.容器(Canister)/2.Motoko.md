Motoko 的设计精巧，目标明确，旨在建立一门易学易用且功能强大的编程语言，专门用于互联网计算机的应用开发。它可以安全编译为 Wasm 字节码部署到 Canister 里。

它借鉴了 Java 、C# 、JavaScript 、Swift 、Pony 、ML 、Haskell 等语言的设计的优点，为程序员提供了一个易于上手和使用的开发工具。它的语法风格像 JavaScript / TypeScript ，不过比 JavaScript 还简洁。

<br>

Motoko 蕴含着设计者对未来的远见和理想。深入了解之后你说不定会对它简洁优雅的语法设计赞叹不已。

Motoko 追求简单，采用易懂的语法，让普通开发者也能轻松上手。它完美支持 Actor 模型，是编写分布式程序的绝佳选择。它与 WebAssembly 和 IC 的执行模型高度契合，可以充分发挥硬件性能。它对未来的扩展需求也做了考虑，预留了兼容性。

Motoko 是基于类的面向对象语言，对象即闭包。类可以是 Actor 模型。

还有一些特点：

- Async 构造用于直接风格的异步消息编程。
- 结构化类型系统，简单的泛型和子类型。
- 溢出检查的数字类型，显式转换。

<div class="center-image">
    <img src="assets/2.Motoko/image-20230916203428940.png" style="zoom: 40%;" />
</div>

所以赶紧来看看 Motoko 的[源代码](https://github.com/dfinity/motoko)和[基础库](https://github.com/dfinity/motoko-base)吧！你可以继续深入了解 [Motoko 使用文档](https://internetcomputer.org/docs/current/motoko/main/overview)。

你还可以通过 [Motoko Playground](https://m7sm4-2iaaa-aaaab-qabra-cai.ic0.app/) 直接部署和测试 Motoko 代码，只要打开浏览器的一个网页就可以！极大地降低了使用 Motoko 和 IC 的门槛。Dfinity 的 Motoko 团队也经常使用 Playground 来测验各种简单的 Motoko 代码。

还有 Motoko 的包管理器 [mops](https://j4mwm-bqaaa-aaaam-qajbq-cai.ic0.app) 、[Vessel](https://github.com/dfinity/vessel) 也是 Motoko 生态很重要的一部分。仅需几行配置代码，就可以帮开发者把第三方库拉到自己的项目，或发布自己的库给其他开发者使用。

不止上面这些，社区里还有[更多关于 Motoko 的内容](https://github.com/motoko-unofficial/awesome-motoko)。

<br>

## 互联网计算机的愿景

要充分理解 Motoko 的设计理念和目标，我们首先需要简要地了解一下背后驱动其诞生的互联网计算机项目。Dfinity 基金会正在积极推进这个雄心勃勃的项目，其终极目标是构建一个 “ 世界计算机 ” ，也就是一个足够强大且对所有人开放的分布式计算平台，它将为人类进入一个更加自由和开放的数字文明时代提供基础。

概括来说，互联网计算机项目试图打造一种全新的公共计算基础设施，类似我们现在使用的互联网，但是其区别在于计算和数据存储是发生在很多个服务器上，而不是集中在大型数据中心的服务器上。这种架构上的不同带来了极大的去中心化优势，使其具有内在的隐私保护性、安全性和可扩展性。

为了实现这个宏伟的愿景，Dfinity 需要在底层网络协议到软件生态系统各个层面进行技术创新。而作为这个层层创新的基石，也需要设计一门面向这个新平台的编程语言，为开发者提供直接开发应用的支持。Motoko 应运而生，它在语言这个层面上，将互联网计算机的核心理念具体化和实践化，为构建这个新世界的软件基础提供了关键支撑。

<br>

## Motoko的设计理念

作为一门全新打造的语言，Motoko 在整体设计上进行了多方面的思考和创新，所有这些设计决策的指导原则都是充分利用这门语言来开发互联网计算机这个崭新的环境。

Motoko 是一门强类型的基于 Actor 的语言，并内置支持正交持久性和异步消息传递。其生产力和安全特性包括自动内存管理、泛型、类型推断、模式匹配，以及任意精度和固定精度算术。消息传递透明，采用了互联网计算机的 Candid 接口定义语言和线格式，实现类型化的高级跨语言互操作性。

以下几点是 Motoko 的核心设计理念：

- 基于 Actor 模型：Motoko 采用了 Actor 模型作为其并发和分布式编程的核心抽象。Actor 是一种天生支持异步和并发的编程实体。一个 Motoko 程序由多个 Actor 组成。这种模型非常适合构建分布式系统。

- 支持异步消息传递：Actor 之间主要通过异步传递消息进行交互。这种通信方式非常适合网络环境，可以避免阻塞和等待。

- 内置正交持久性：Motoko 通过语言层面的抽象极大地简化了状态持久化这一复杂问题。开发者可以忽略状态保存和恢复的细节。

- 面向安全的设计：Motoko 在类型系统、运行时和并发控制方面都加强了各种检查和保护，大幅提高了程序的健壮性和安全性。

- 多语言互操作性：Motoko 使用一种通用的接口定义语言，以实现不同语言编写的模块之间的安全互操作。

- 编译为 WebAssembly ：利用 WebAssembly 带来的各项优势，包括可移植性、安全性和效率。

可以看到，这些设计理念都紧密地契合了互联网计算机的架构特征和应用需求，使 Motoko 成为在这个崭新的分布式平台上进行应用开发的理想语言。

<br>

## Motoko语言特性概览

除了整体设计理念外，Motoko 语言本身作为一门通用编程语言，也集成了当代语言设计中许多优秀的特性和理念。

- 静态类型系统：提供编译期类型检查，可以发现部分错误。
- 自动内存管理：有编译器管理内存，通过引用计数回收不再使用的对象。
- 泛型：支持泛型，提高代码复用性。
- 类型推断：编译器可以推断大部分类型，但有时需要类型注解。
- 模式匹配：支持模式匹配不同类型的值。
- 不可变性：变量默认不可变，使用 var 声明可变变量。
- 可选类型：有可选类型以代替空值。
- 溢出检查：运行时检查整数溢出。
- 并发安全：Actor 消息处理是原子的，在一个函数调用过程内保持原子性。

上述这些语言特性可见， Motoko 汲取了过去几十年编程语言理论与实践的精华，将许多有助于可靠性和生产力的现代语言特性融入其中。

<br>

## Actor模型与异步处理

Actor 是 Motoko 中的一种核心抽象，代表一个并发执行的实体。Motoko 程序由多个 Actor 组成，它们之间通过异步消息传递进行交互，没有任何共享状态。每个 Actor 都有其自己私有的可变状态。发送消息给 Actor 不会造成发送方阻塞，Actor 根据自身状态进行并发地消息处理。

这种基于消息传递的 Actor 模型非常适合构建分布式系统。在互联网计算机上，Actor 会编译成能够跨网络进行通信的模块，成为所谓的 Canister 。

<br>

为了使异步编程更加便捷，并能够以顺序的 “ 直接风格 ” 来表达它。在 Motoko 中采用了另一个 40 多年前的编程语言用来研究历史记载中的想法，而且更幸运的是，这个想法最近变得更加流行了：Futures（在一些社区中也称为 promise（前途或者希望）），在 Motoko 中，它们以 “ 异步值 ” 的形式实现，类型为 “ 异步 ” 的值由前缀为 “ async ” 关键字的表达式产生。值得一提的是，函数体可以是一个异步表达式，因此很自然地取代了存在于其他一些语言中更单一的 “ 异步函数 ” 概念。

这样来看，演绎的方法就可以有结果了——只要这些结果是未来的。未来可以等待获得他们的值，但是只能在另一个异步表达式中进行，类似于其他编程语言中的异步或者等待单元。

<br>

## 正交持久性抽象

对于构建分布式系统来说，状态的保存和恢复是一个非常关键也非常复杂的问题。传统上，开发者需要自己处理各种检查点的保存和恢复逻辑。而 Motoko 在语言层面做了抽象，提供了 “ 正交持久性 ” 功能，极大地减轻了开发者的工作。

<br>

所谓正交持久性，就是状态持久化与程序业务逻辑两个关注点的正交化。

开发者只需要关注编写业务应用程序的逻辑，不必担心状态的保存和恢复。这项复杂的工作被抽象出去，有运行时环境处理，对开发者是透明的。

这样，业务逻辑与状态持久化这两个交叉的关注点被分离开来，开发者只需要关注前者，可以专注在应用本身的功能上。

这种抽象使开发者可以更加专注于应用程序本身的业务逻辑。底层平台会透明地处理状态的持久化，在 Actor 重新启动时进行恢复，开发者不必操心这些细节。

<br>

Motoko 的正交持久性是如何实现的呢？关键在于它提供了一个 “ 永生运行 ” 的抽象模型。

对于程序员来说，写 Motoko 代码就像是在一个永远存在的运行环境中一样，变量和状态会持续存在，不存在程序重启的概念。

而底层平台会透明地进行状态持久化，在 Actor 重新启动时，自动进行状态恢复，程序继续执行就像无事发生一样。

具体技术上，平台会跟踪 Actor mutable 状态的变化，在每次消息处理之前保存快照，在 Actor 重新启动时进行恢复。对于不可变状态，则完全不需要特殊处理。

正交持久性带来了以下优点：

* 开发者可以更加专注于业务逻辑，不必分心处理状态持久化问题。
* 避免了重复编写检查点保存和恢复代码的劳动。
* 状态持久化代码被统一优化，提高了效率。
* 简化了开发复杂分布式系统的难度。
* 新手程序员也可以更轻松地上手。
* 可测试性增强，可以将测试局限在单次执行中。

通过提供正交持久性抽象，Motoko 极大地简化和改善了构建分布式系统时必须解决的一个关键难题，这是一个非常巧妙的语言层面设计的创新。

<br>

## 多语言互操作性

考虑到互联网计算机是一个开放的环境，不同的开发团队可能会使用各自偏好的编程语言进行开发，为了使这些不同语言编写的模块可以平滑地互操作，Motoko 采用了一种通用的接口描述语言 Candid 。

每个 Canister 使用 Candid 描述其对外提供的接口和消息类型。Motoko 编译器可以自动将这些接口映射到 Motoko 内部类型。这样，使用不同语言开发的 Canister 可以通过这些共享接口进行交互，同时类型安全也得到保证。

这种跨语言互操作性机制对一个开放的分布式计算平台来说是必须的。

<br>

## WebAssembly

Motoko 编译器生成的最终目标是 WebAssembly（缩写 Wasm ）。选择 Wasm 作为目标，是 Motoko 设计者经过深思熟虑的结果，主要基于以下考虑：

**什么是 WebAssembly**

WebAssembly 是一个面向未来的通用低级字节码格式，它的设计目标是可移植、安全和高效。最初是针对 Web 应用的需求开发的，但实际上适用范围更广。

Wasm 模块通过类似汇编语言的字节码在沙盒环境中执行，和具体语言无关。运行时通过栈来执行指令。相比虚拟机，Wasm 更贴近硬件，没有语言特定的优化。

**为什么选择 Wasm**

Motoko 选择 Wasm 作为编译目标、Canister 采用 Wasm，主要基于以下几点考虑：

- **可移植性**。Wasm 可以运行在支持它的任意平台上，不依赖特定语言或操作系统。
- **安全性**。Wasm 的沙盒化执行保证了代码的安全隔离。这对区块链和去中心化应用尤为重要。
- **效率**。Wasm 的执行效率接近原生代码，对性能要求高的 IC 很关键。
- **异步性**。Wasm 对异步调用提供了支持，很适合 Actor 模型。
- **未来性**。Wasm 正在快速发展并成为行业标准，有几大浏览器巨头合作推进，选择它更加未来。

选择 Wasm 具有以下优势：

- 可以跨平台运行，具备极强的可移植性。

- 沙盒化执行提供了安全性保证。

- 执行效率接近原生代码，对性能非常关键。

- 内置的异步调用机制，适合 Actor 模型。

- Wasm 作为通用标准，其未来发展前景非常 optimistic 。

- Motoko 直接编译到 IC 运行的目标代码，技术一致性。

Motoko 选择 Wasm 作为编译目标，是其设计中一个极为明智的选择。利用 Wasm 的各项优势，对 Motoko 的跨平台性、安全性和效率都提供了保证。支持一次部署，到处运行。也使其业界影响力更大。可以说这是一种典范级的工程技术选择。

<br>

## 总结

Motoko 是 Dfinity 基金会呕心沥血打造的一门全新语言，旨在为其激进的互联网计算机项目提供编程语言层面的支持。

Motoko 在总体设计上采用了 Actor 模型、内置正交持久性等创新理念，语言本身也集成了静态类型检查、自动内存管理等优秀特性。可以说 Motoko 在设计上进行了多方面的大量创新，这些设计决策都旨在减少开发者的心智负担，让他们可以专注于构建这个面向未来的分布式计算平台之上的应用软件。

虽然作为新语言 Motoko 还有大量工作要做，但它的雄心勃勃充满了对未来的想象。随着时间的推移，相信 Motoko 会日益成熟，最终成为构建互联网计算机世界的一个强力工具。

现在了解完 Motoko 了，来试试[部署自己的 Canister](3.部署自己的Canister.md) 吧。

<br>

官方资料：https://medium.com/dfinity/motoko-a-programming-language-designed-for-the-internet-computer-is-now-open-source-8d85da4db735

