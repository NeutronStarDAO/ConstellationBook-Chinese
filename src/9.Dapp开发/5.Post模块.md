

## Post

ç”¨æˆ·é€šè¿‡ Feed å‘å¸ƒå’Œè·å–åŠ¨æ€ï¼Œæ‰€æœ‰çš„å¸–å­éƒ½å­˜åœ¨ Bucket é‡Œã€‚é€šçŸ¥æŠ“å–çš„åŠŸèƒ½åˆ™é€šè¿‡ Fetch è¿›è¡Œå¤„ç†ã€‚

æˆ‘ä»¬ä¸‹ä¸€ä¸ªè¦å®ç°çš„æ˜¯ Post æ¨¡å—ã€‚ä½†æ˜¯æˆ‘ä»¬éœ€è¦ç”¨çš„ç±»å‹æœ‰å¸–å­ã€ç‚¹èµã€è¯„è®ºï¼Œè¿˜è¦å’Œå…¶ä»– Canister äº¤äº’ï¼Œè€Œä¸”è¿™äº›ç±»å‹åœ¨ Feed ã€Fetch é‡Œè¿˜éœ€è¦ç”¨ã€‚

æ‰€ä»¥å¯¹äºè¦å…¨å±€å…±äº«çš„ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå®ƒæ”¾åœ¨æ¨¡å—æ–‡ä»¶å¤¹ä¹‹å¤–ï¼š

```
src
  â”œâ”€â”€ feed
  â”œâ”€â”€ fetch
  â”œâ”€â”€ post
  â”œâ”€â”€ user
  â”œâ”€â”€ types.mo  ğŸ‘ˆ
  â””â”€â”€ utils.mo
```

åœ¨ä½¿ç”¨æ—¶å…ˆæŠŠ types.mo çš„å†…å®¹å¼•ç”¨åˆ°æ¨¡å—æ–‡ä»¶å¤¹å†…çš„ types.mo é‡Œã€‚å†å¼•å…¥å…¶ä»–æ–‡ä»¶é‡Œã€‚

<br>

æ¯”å¦‚æŠŠå¸–å­è¿™ä¸ªç±»å‹å®šä¹‰å¥½ï¼šä»£è¡¨äº†ç”¨æˆ·å‘å¸ƒçš„å¸–å­ï¼Œç„¶åæ”¾åˆ°å¤–å±‚æ–‡ä»¶å¤¹çš„ types.mo é‡Œï¼Œå…·ä½“å¯ä»¥çœ‹ [8.å…±äº«ç±»å‹](./8.å…±äº«ç±»å‹.md) ã€‚å¸–å­åŒ…æ‹¬äº†å¾ˆå¤šä¿¡æ¯ï¼Œæ¯”å¦‚å¸–å­çš„ ID ã€å‘å¸ƒè€…ã€å¸–å­ç´¢å¼•ã€å‘å¸ƒæ—¶é—´ã€å†…å®¹ã€ç‚¹èµæ•°ã€è¯„è®ºç­‰ç­‰ã€‚

```motoko
public type Post = {
    postId: PostId;
    feedCanister: Principal;
    index: Nat;
    user: UserId;
    content: Text;
    var repost: [Repost];
    var like: [Like];
    var comment: [Comment];
    createdAt: Time;
};
```

<br>

<div class="center-image">
<img src="assets/2.è®¾è®¡DApp/image-20231120173647549.png" style="zoom:45%;" />
</div>

æ ¹æ®ä¹‹å‰çš„è®¾è®¡ï¼Œåœ¨ Post æ¨¡å—é‡Œæœ‰ 2 ç§ Canister ï¼šRoot Post å’Œ Bucket ã€‚

Root Post è´Ÿè´£ç»Ÿç­¹ç®¡ç†æ‰€æœ‰çš„ Bucket ï¼š

* åˆ›å»ºè¶³å¤Ÿå¤šçš„ Bucket ï¼ˆå§‹ç»ˆä¿æŒ 5 ä¸ªå¯ç”¨ï¼‰ã€‚

* æŸ¥è¯¢æ‰€æœ‰ Bucket ã€å¯ç”¨çš„ Bucket ã€å·²å­˜æ»¡çš„ Bucket ç­‰ã€‚

<br>

Bucket æ˜¯ç›´æ¥å­˜å‚¨å¸–å­å†…å®¹çš„åœ°æ–¹ï¼š

* å­˜å‚¨å¸–å­ã€‚

* æŸ¥è¯¢å¸–å­æ€»æ•°é‡ã€æ ¹æ®å¸–å­ ID æŸ¥è¯¢å•ä¸ªå¸–å­ã€æŸ¥è¯¢å¤šä¸ªå¸–å­ã€è·å–æœ€æ–°å¸–å­ã€‚

* åœ¨æ”¶åˆ°æ–°è¯„è®ºåï¼Œé€šè¿‡ CommentFetch é€šçŸ¥ã€‚

* åŒæ ·ç»´æŠ¤äº†ä¸¤ä¸ªå­æ¨¡å—çš„åœ°å€ï¼Œæä¾›äº†æ›´æ–°å’ŒæŸ¥è¯¢è¿™ä¸¤ä¸ª Canister çš„å‡½æ•°ã€‚

* Bucket é€šè¿‡ `checkBucketMemory` å‡½æ•°æ£€æŸ¥å¸–å­æ•°é‡ï¼Œå½“æ¥è¿‘é˜ˆå€¼æ—¶é€šçŸ¥æ ¹å¸–å­æ¨¡å—é‡æ–°åˆ›å»º Bucket ã€‚

<br>

### ç®¡ç†Canisterï¼šrootPost.mo

çœ‹çœ‹ Root Post Canister ã€‚Root Post éœ€è¦ç®¡ç† Bucketï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ `TrieMap` è®°å½•ã€‚ç”¨ `TrieMap` è®°å½•ä¸‰ç§ä¸åŒçŠ¶æ€çš„ Bucket ï¼š`buckets` å­˜å‚¨æ‰€æœ‰å·²åˆ›å»ºçš„ Bucket ï¼Œ`availableBuckets` å­˜å‚¨å¯ç”¨çš„ Bucket ï¼Œ`unavailableBuckets` å­˜å‚¨å·²ç»å­˜æ»¡çš„ Bucket ã€‚

å› ä¸ºéƒ¨ç½² Canister ä¹‹åéœ€è¦å…ˆåˆ›å»º 5 ä¸ª Canister ï¼Œæˆ‘ä»¬è¿˜éœ€è¦åˆå§‹åŒ–å‡½æ•°ï¼Œä»¥åŠåç»­å¯ä»¥æ–°å¢ Bucket ã€‚åœ¨åˆ›å»º Bucket æ—¶ï¼Œè¿˜å¾—å‘Šè¯‰ Bucket ç³»ç»Ÿä¸­çš„ Comment Fetch å’Œ Like Fetch çš„ Canister ID ï¼Œæ‰€ä»¥åœ¨ Root Post ä¸­ï¼Œæˆ‘ä»¬è¿˜è¦è®°å½•ã€ä¿å­˜ Comment Fetch å’Œ Like Fetch ã€‚

æœ€åæ˜¯æŸ¥è¯¢æ‰€æœ‰ Bucket ã€æŸ¥è¯¢å¯ç”¨çš„ Bucket ã€æŸ¥è¯¢å·²ç»å­˜æ»¡çš„ Bucket ã€‚

<br>

å…ˆå®šä¹‰ä¸€äº› stable å˜é‡å’Œæ˜ å°„æ¥ä¿å­˜ Bucket ã€‚

åœ¨ Motoko ä¸­ï¼Œ`stable` å…³é”®å­—ç”¨äºå®šä¹‰ç¨³å®šå˜é‡ï¼ˆStable variablesï¼‰ã€‚è¿™äº›å˜é‡çš„å€¼åº”åœ¨ Canister å‡çº§è¿‡ç¨‹ä¸­ä¿æŒæŒä¹…æ€§ã€‚è¿™æ˜¯ Motoko ç‰¹æœ‰çš„åŠŸèƒ½ï¼Œå®ƒä½¿ç”¨ ICP çš„ç¨³å®šå†…å­˜ï¼ˆStable memoryï¼‰æ¥åœ¨ Canister å‡çº§è¿‡ç¨‹ä¸­ä¿æŒæ•°æ®çš„æŒä¹…æ€§ã€‚ç¨³å®šå†…å­˜æ˜¯ IC å¯ä»¥é•¿æœŸå­˜å‚¨æ•°æ®çš„ç‰¹æ€§ï¼Œä¸å—è¯­è¨€é™åˆ¶ï¼Œ Motoko ã€Rust æˆ–ä»»ä½•å…¶ä»–è¯­è¨€å†™çš„ Canister éƒ½å¯ä»¥ç”¨ã€‚ç¨³å®šå†…å­˜å¯ä»¥å®¹çº³é«˜è¾¾ 400 GiB çš„æ•°æ®ï¼Œå¦‚æœå­ç½‘å¯ä»¥å®¹çº³çš„è¯ã€‚

é€šè¿‡è¿™äº› stable å˜é‡å’Œæ˜ å°„çš„å®šä¹‰ï¼Œå¯ä»¥æŒä¹…åŒ–ä¿å­˜å¤šä¸ª Bucket çš„çŠ¶æ€ã€æ€»é‡ç­‰ä¿¡æ¯ï¼Œå¹¶åœ¨ Canister å‡çº§åç»§ç»­ä½¿ç”¨ï¼Œå®ç°äº† Bucket ç®¡ç†çš„æŒä¹…åŒ–ã€‚

```js
stable let T_CYCLES = 1_000_000_000_000; // æå‰å®šä¹‰å¥½1T Cyclesï¼Œæ–¹ä¾¿åç»­ä½¿ç”¨
stable let BUCKET_MAX_POST_NUMBER: Nat = 5000; // è®°å½•æ¯ä¸ªBucketå¯ä»¥å­˜å‚¨çš„æœ€å¤§å¸–å­æ•°
stable var bucketIndex: Nat = 0; // bucketIndexè®°å½•å·²ç»åˆ›å»ºçš„Bucketæ•°é‡

// å®šä¹‰ä¸€ä¸ªæ•°ç»„ï¼Œä¿å­˜æ‰€æœ‰å·²ç»åˆ›å»ºçš„Bucketçš„ä¿¡æ¯
stable var bucketsEntries: [(Nat, Principal)] = [];
// bucketsæ˜¯æ ¹æ®bucketsEntriesåˆ›å»ºçš„æ˜ å°„è¡¨ï¼Œé”®æ˜¯ç´¢å¼•ï¼Œå€¼æ˜¯Bucketçš„principal
let buckets = TrieMap.fromEntries<Nat, Principal>(bucketsEntries.vals(), Nat.equal, Hash.hash);

// availableBucketsEntrieså’ŒavailableBucketsç”¨äºè®°å½•å½“å‰å¯ç”¨çš„Bucket
stable var availableBucketsEntries: [(Nat, Principal)] = [];
let availableBuckets = TrieMap.fromEntries<Nat, Principal>(availableBucketsEntries.vals(), Nat.equal, Hash.hash);

// unavailableBucketsEntrieså’ŒunavailableBucketsç”¨äºè®°å½•å½“å‰ä¸å¯ç”¨çš„Bucket
stable var unavailableBucketsEntries: [(Nat, Principal)] = [];
let unavailableBuckets = TrieMap.fromEntries<Nat, Principal>(unavailableBucketsEntries.vals(), Nat.equal, Hash.hash);
```

<br>

` _createBucket()` å‡½æ•°åˆ›å»º Canister ï¼š

ä½¿ç”¨ Bucket.Bucket å¯¹è±¡çš„ Bucket å‡½æ•°åˆ›å»ºä¸€ä¸ªæ–°çš„ Bucket actor ï¼Œä¼ å…¥ Root Post Canister çš„ principalï¼ˆ ID ï¼‰ ã€commentFetchCanister å’Œ likeFetchCanister ä½œä¸ºå‚æ•°ã€‚

```js
// åˆ›å»ºBucketçš„é€»è¾‘
private func _createBucket(): async Principal {
    // ç»™æ¯ä¸ªBucketæ·»åŠ 4T Cycles
    Cycles.add(4 * T_CYCLES);
    let newBucket = await Bucket.Bucket(
        Principal.fromActor(this),
        commentFetchCanister,
        likeFetchCanister
    );

    // å°†æ–°åˆ›å»ºçš„Bucketçš„principalä¿å­˜åˆ°bucketsæ˜ å°„è¡¨ä¸­ï¼Œé”®ä¸ºå½“å‰çš„bucketIndex
    buckets.put(bucketIndex, Principal.fromActor(newBucket));
    // åŒæ—¶ä¹Ÿä¿å­˜åˆ°availableBucketsæ˜ å°„è¡¨ä¸­ï¼Œè¡¨ç¤ºè¿™ä¸ªBucketå½“å‰å¯ç”¨
    availableBuckets.put(bucketIndex, Principal.fromActor(newBucket));

    // bucketIndexåŠ 1ï¼Œè¡¨ç¤ºå·²åˆ›å»ºBucketæ•°é‡å¢åŠ 
    bucketIndex += 1;
    
    // è¿”å›æ–°åˆ›å»ºçš„Bucketçš„principal
    Principal.fromActor(newBucket)
};
```

è¿™æ · `_createBucket()` å‡½æ•°å°±å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„ Bucket Actor ï¼Œå¹¶ä¿å­˜å®ƒçš„ principal åˆ°ä¸¤ä¸ªæ˜ å°„è¡¨ä¸­è¡¨ç¤ºå·²åˆ›å»ºå’Œå¯ç”¨çŠ¶æ€ã€‚

å®ƒå°è£…äº†åˆ›å»º Bucket çš„å…·ä½“é€»è¾‘ï¼Œä½œä¸ºä¸€ä¸ªç§æœ‰å‡½æ•°è¢« `createBucket()` å…¬å¼€å‡½æ•°è°ƒç”¨ã€‚ä½¿ç”¨ `bucketIndex` æ ‡è¯†æ¯ä¸ª Bucketï¼Œå¹¶åœ¨åˆ›å»ºåå¢åŠ è¯¥ç´¢å¼•ã€‚

æˆ‘ä»¬å¯ä»¥æ–¹ä¾¿åœ°æ‰¹é‡åˆ›å»º Bucket ï¼Œå¹¶æ˜ç¡®å…¶çŠ¶æ€ï¼Œä¹Ÿä¸ºç®¡ç†å¤šä¸ª Bucket æä¾›äº†ä¾¿åˆ©ã€‚

<br>

 æ¥ä¸‹æ¥ç»§ç»­æ„å»ºåˆ›å»ºå’Œç®¡ç†å¤šä¸ª Bucket çš„å‡½æ•°ã€‚

```js
// å¼€å§‹å…ˆåˆ›å»º5ä¸ªBucketï¼Œå¹¶æŠŠå®ƒä»¬æ·»åŠ åˆ°bucketså’ŒavailableBucketsçš„æ˜ å°„è¡¨ä¸­
public shared({caller}) func init(): async () {
    var i = 0;
    label l loop {
        if(i >= 5) break l;

        Cycles.add(4 * T_CYCLES);
        let newBucket = await Bucket.Bucket(
            Principal.fromActor(this),
            commentFetchCanister,
            likeFetchCanister
        );

        buckets.put(bucketIndex, Principal.fromActor(newBucket));
        availableBuckets.put(bucketIndex, Principal.fromActor(newBucket));
        bucketIndex += 1;

        i += 1;
    };
};

// æ‰¹é‡æ·»åŠ å·²ç»åˆ›å»ºå¥½çš„Bucketåˆ°bucketså’ŒavailableBucketsä¸­
public shared({caller}) func addAvailBucket(bucketArray: [Principal]): async () {
    for(_bucket in bucketArray.vals()) {
        buckets.put(bucketIndex, _bucket);
        availableBuckets.put(bucketIndex, _bucket);
        bucketIndex += 1;
    };
};

// è¿”å›å½“å‰å·²ç»åˆ›å»ºçš„Bucketæ•°é‡
public query func getBucketIndex(): async Nat { bucketIndex };

// å…¬å¼€åˆ›å»ºBucketçš„å‡½æ•°ï¼Œå†…éƒ¨è°ƒç”¨_createBucket()
public shared({caller}) func createBucket(): async Principal {
    await _createBucket()
};
```

ç°åœ¨æˆ‘ä»¬çš„ä¸€ä¸ª Canister å¯ä»¥ç®¡ç† Bucket çš„åˆ›å»ºã€æ·»åŠ äº†ã€‚æ‰€æœ‰ Bucket çš„åˆ›å»ºå’Œç”Ÿå‘½å‘¨æœŸèƒ½å¤Ÿè¢«é›†ä¸­ç®¡ç†ã€‚

<br>

ä¹‹åè¿˜è¦å†™å‡ºæŸ¥è¯¢å‡½æ•°ï¼š

```js
// æŸ¥è¯¢å¯ç”¨çš„Bucket
public query func getAvailableBucket(): async ?Principal {
    if(availableBuckets.size() == 0) return null;
    availableBuckets.get(Nat.rem(Option.unwrap(Nat.fromText(Int.toText(Time.now()))), availableBuckets.size()))
};

// æŸ¥è¯¢æ‰€æœ‰çš„Bucket
public query func getAllBuckets(): async [Principal] {
    Iter.toArray(buckets.vals())
};

// æŸ¥è¯¢æ‰€æœ‰å¯ç”¨çš„Bucket
public query func getAllAvailableBuckets(): async [Principal] {
    Iter.toArray(availableBuckets.vals())
};

// æŸ¥è¯¢å·²ç»å­˜æ»¡çš„Bucket
public query func getAllUnavailableBuckets(): async [Principal] {
    Iter.toArray(unavailableBuckets.vals())
};
```

<br>

åœ¨åˆ›å»º Bucket æ—¶ï¼Œæˆ‘ä»¬è¿˜å¾—å‘Šè¯‰ Bucket ç³»ç»Ÿä¸­çš„ Comment Fetch å’Œ Like Fetch çš„ Canister ID ï¼Œæ‰€ä»¥åœ¨ Root Post ä¸­ï¼Œæˆ‘ä»¬è¿˜è¦è®°å½•ã€ä¿å­˜ Comment Fetch å’Œ Like Fetch ï¼š

```js
// æŒä¹…åŒ–ä¿å­˜commentFetch canisterçš„principal id
stable var commentFetchCanister = _commentFetchCanister;

// å¤–éƒ¨å¯ä»¥æŸ¥è¯¢å½“å‰ä¿å­˜çš„commentFetch canister id
public query func getCommentFetchCanister(): async Principal { commentFetchCanister };

// æˆæƒç‰¹å®šçš„calleræ›´æ–°ä¿å­˜çš„commentFetch canister id
public shared({caller}) func updateCommentFetchCanister(
    newCommentFetchCanister: Principal
): async () {
    commentFetchCanister := commentFetchCanister;
};
```

ç°åœ¨ likeFetch canister çš„ principal ID å¯ä»¥è¢«æŒä¹…åŒ–ä¿å­˜ï¼Œå¹¶å¯ä»¥é€šè¿‡ update å‡½æ•°çµæ´»æ›´æ–°ï¼Œè¿˜èƒ½è¢«å¤–éƒ¨ç¨‹åºè¯»å–æŸ¥è¯¢ã€‚

```js
// æŒä¹…åŒ–ä¿å­˜likeFetch canisterçš„principal id
stable var likeFetchCanister = _likeFetchCanister;
    
// å¤–éƒ¨å¯ä»¥æŸ¥è¯¢å½“å‰ä¿å­˜çš„likeFetch canister id
public query func getLikeFetchCanister(): async Principal { likeFetchCanister };

// æˆæƒç‰¹å®šçš„calleræ›´æ–°ä¿å­˜çš„likeFetch canister id
public shared({caller}) func updateLikeFetchCanister(
    newLikeFetchCanister: Principal
): async () {
    likeFetchCanister := newLikeFetchCanister;
};
```

<br>

æœ€åæ˜¯ä¸¤ä¸ªç³»ç»Ÿå‡½æ•° `preupgrade()` å’Œ `postupgrade()` ï¼Œç”¨æ¥åœ¨ Canister å‡çº§å‰åä¿å­˜å’Œé‡ç½® buckets ã€availableBuckets å’Œ unavailableBuckets çš„ entries ã€‚

```js
system func preupgrade() {
    bucketsEntries := Iter.toArray(buckets.entries());
    availableBucketsEntries := Iter.toArray(availableBuckets.entries());
    unavailableBucketsEntries := Iter.toArray(unavailableBuckets.entries());
};

system func postupgrade() {
    bucketsEntries := [];
    availableBucketsEntries := [];
    unavailableBucketsEntries := [];
};
```

`preupgrade()` å‡½æ•°åœ¨ Canister å‡çº§å‰è¢«è°ƒç”¨ï¼Œå®ƒå°† buckets ã€availableBuckets å’Œ unavailableBuckets ä¸­çš„æ‰€æœ‰ entries ä¿å­˜åˆ°å¯¹åº”çš„æ•°ç»„ bucketsEntries ã€availableBucketsEntries å’Œ unavailableBucketsEntries ä¸­ã€‚

`postupgrade()` å‡½æ•°åœ¨ Canister å‡çº§åè¢«è°ƒç”¨ï¼Œå®ƒå°† bucketsEntries ã€availableBucketsEntries å’Œ unavailableBucketsEntries æ•°ç»„æ¸…ç©ºï¼Œç›¸å½“äºé‡ç½®äº† buckets ã€availableBuckets å’Œ unavailableBuckets ä¸­çš„æ•°æ®ã€‚

è¿™æ ·ï¼Œé€šè¿‡åœ¨å‡çº§å‰åä¿å­˜å’Œé‡ç½® entries ï¼Œå¯ä»¥ä½¿ buckets ã€availableBuckets å’Œ unavailableBuckets ä¸­çš„æ•°æ®åœ¨ Canister å‡çº§åä¸ä¸¢å¤±ã€‚

`preupgrade` å’Œ `postupgrade` è¢«å®šä¹‰ä¸ºç³»ç»Ÿå‡½æ•°ï¼Œä¼šç”± Runtime è‡ªåŠ¨è°ƒç”¨ï¼Œå¼€å‘è€…ä¸éœ€è¦è‡ªå·±è°ƒç”¨ã€‚

è¿™æ®µä»£ç å®ç°äº† Canister å‡çº§çš„æ•°æ®è¿ç§»ï¼Œé€šè¿‡åœ¨å‡çº§å‰åä¿å­˜å’Œé‡ç½®çŠ¶æ€ï¼Œä¿è¯äº† Canister å‡çº§çš„é€æ˜æ€§ã€‚

<br>

<div class="center-image">
<img src="assets/5.Postæ¨¡å—/image-20240130131002611.png" alt="image-20240130131002611" style="zoom:39%;" />
</div>

ä»¥ä¸‹æ˜¯ rootPost.mo çš„å®Œæ•´æ–‡ä»¶ï¼š

```js
import Hash "mo:base/Hash";
import Nat "mo:base/Nat";
import TrieMap "mo:base/TrieMap";
import Principal "mo:base/Principal";
import Types "./types";
import Bucket "./bucket";
import Iter "mo:base/Iter";
import Cycles "mo:base/ExperimentalCycles";
import Time "mo:base/Time";
import Int "mo:base/Int";
import Option "mo:base/Option";
import IC "mo:ic";

actor class RootPost(
    _commentFetchCanister: Principal,
    _likeFetchCanister: Principal
) = this {

    stable let T_CYCLES = 1_000_000_000_000;
    stable let BUCKET_MAX_POST_NUMBER: Nat = 5000; // æ¯ä¸ªBucketå¯ä»¥å­˜å‚¨çš„æœ€å¤§å¸–å­æ•°
    stable var bucketIndex: Nat = 0;

    stable var bucketsEntries: [(Nat, Principal)] = [];
    let buckets = TrieMap.fromEntries<Nat, Principal>(bucketsEntries.vals(), Nat.equal, Hash.hash);

    stable var availableBucketsEntries: [(Nat, Principal)] = [];
    let availableBuckets = TrieMap.fromEntries<Nat, Principal>(availableBucketsEntries.vals(), Nat.equal, Hash.hash);

    stable var unavailableBucketsEntries: [(Nat, Principal)] = [];
    let unavailableBuckets = TrieMap.fromEntries<Nat, Principal>(unavailableBucketsEntries.vals(), Nat.equal, Hash.hash);

    // å¼€å§‹å…ˆåˆ›å»º 5 ä¸ª Bucket
    public shared({caller}) func init(): async () {
        var i = 0;
        label l loop {
            if(i >= 5) break l;

            Cycles.add(4 * T_CYCLES);
            let newBucket = await Bucket.Bucket(
                Principal.fromActor(this),
                commentFetchCanister,
                likeFetchCanister
            );

            buckets.put(bucketIndex, Principal.fromActor(newBucket));
            availableBuckets.put(bucketIndex, Principal.fromActor(newBucket));
            bucketIndex += 1;

            i += 1;
        };
    };

    public shared({caller}) func addAvailBucket(bucketArray: [Principal]): async () {
        for(_bucket in bucketArray.vals()) {
            buckets.put(bucketIndex, _bucket);
            availableBuckets.put(bucketIndex, _bucket);
            bucketIndex += 1;
        };
    };

    public query func getBucketIndex(): async Nat { bucketIndex };

    // åˆ›å»ºBucket
    public shared({caller}) func createBucket(): async Principal {
        await _createBucket()
    };

    // åˆ›å»ºBucketçš„é€»è¾‘
    private func _createBucket(): async Principal {
        Cycles.add(4 * T_CYCLES);
        let newBucket = await Bucket.Bucket(
            Principal.fromActor(this),
            commentFetchCanister,
            likeFetchCanister
        );

        buckets.put(bucketIndex, Principal.fromActor(newBucket));
        availableBuckets.put(bucketIndex, Principal.fromActor(newBucket));

        bucketIndex += 1;

        Principal.fromActor(newBucket)
    };

    public shared({caller}) func reCreateBucket(): async () {
        for((_key, _bucket) in availableBuckets.entries()) {
            if(_bucket == caller) {
                ignore await _createBucket();
                availableBuckets.delete(_key);
                unavailableBuckets.put(_key, _bucket);
            };
        };
    };

    // æŸ¥è¯¢å¯ç”¨çš„Bucket
    public query func getAvailableBucket(): async ?Principal {
        if(availableBuckets.size() == 0) return null;
        availableBuckets.get(Nat.rem(Option.unwrap(Nat.fromText(Int.toText(Time.now()))), availableBuckets.size()))
    };

    // æŸ¥è¯¢æ‰€æœ‰çš„Bucket
    public query func getAllBuckets(): async [Principal] {
        Iter.toArray(buckets.vals())
    };

    public query func getAllAvailableBuckets(): async [Principal] {
        Iter.toArray(availableBuckets.vals())
    };

    // æŸ¥è¯¢å·²ç»å­˜æ»¡çš„Bucket
    public query func getAllUnavailableBuckets(): async [Principal] {
        Iter.toArray(unavailableBuckets.vals())
    };

// ==================== CommentFetchCanister ====================

    stable var commentFetchCanister = _commentFetchCanister;
    
    public query func getCommentFetchCanister(): async Principal { commentFetchCanister };

    public shared({caller}) func updateCommentFetchCanister(
        newCommentFetchCanister: Principal
    ): async () {
        commentFetchCanister := commentFetchCanister;
    };


// ==================== LikeFetchCanister ====================

    stable var likeFetchCanister = _likeFetchCanister;
    
    public query func getLikeFetchCanister(): async Principal { likeFetchCanister };

    public shared({caller}) func updateLikeFetchCanister(
        newLikeFetchCanister: Principal
    ): async () {
        likeFetchCanister := newLikeFetchCanister;
    };

    system func preupgrade() {
        bucketsEntries := Iter.toArray(buckets.entries());
        availableBucketsEntries := Iter.toArray(availableBuckets.entries());
        unavailableBucketsEntries := Iter.toArray(unavailableBuckets.entries());
    };

    system func postupgrade() {
        bucketsEntries := [];
        availableBucketsEntries := [];
        unavailableBucketsEntries := [];
    };
}
```

<br>

### å­˜å‚¨å¸–å­ï¼šbucket.mo

Bucket æ˜¯å­˜å‚¨å¸–å­çš„ Canister ï¼Œæ¯ä¸ª Bucket å¯ä»¥å­˜å‚¨ä¸€å®šæ•°é‡çš„å¸–å­ã€‚æ”¯æŒå­˜å‚¨ã€æŸ¥è¯¢ã€æ›´æ–°å¸–å­ä»¥åŠé€šçŸ¥ Fetch Canister çš„åŠŸèƒ½ã€‚

Bucket éœ€è¦æä¾›äº†æŸ¥è¯¢å¸–å­æ•°é‡ã€æ ¹æ®å¸–å­ ID æŸ¥è¯¢å•ä¸ªå¸–å­ã€æŸ¥è¯¢å¤šä¸ªå¸–å­ã€è·å–æœ€æ–°å¸–å­çš„å‡½æ•°ã€‚

åœ¨æ”¶åˆ°æ–°è¯„è®ºã€ç‚¹èµä¹‹åï¼ŒBucket è¿˜è¦é€šè¿‡ Comment Fetch Canister å’Œ Like Fetch Canister ã€‚

å½“ Bucket å­˜å‚¨çš„å¸–å­æ•°é‡æ¥è¿‘é˜ˆå€¼æ—¶ï¼ŒRoot Post ä¼šåˆ›å»ºæ–°çš„ Bucket ã€‚

<br>

è¿™æ˜¯ `Bucket` æ¨¡å—çš„å¼€å§‹ï¼Œå®ƒæ˜¯å®é™…å­˜å‚¨å¸–å­çš„åœ°æ–¹ã€‚å¸¦æœ‰ `actor class` å…³é”®å­—çš„è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªå¯ä»¥è¢«å¤–éƒ¨è°ƒç”¨çš„ Actor ç±»ã€‚å¸¦æœ‰ `(rootPostCanister, _commentFetchCanister, _likeFetchCanister)` å‚æ•°è¡¨ç¤ºè¿™ä¸ª Actor ç±»éœ€è¦åˆå§‹åŒ–æ—¶ä¼ å…¥è¿™ä¸‰ä¸ª Canister çš„ ID ã€‚

```js
actor class Bucket(
    rootPostCanister: Principal,
    _commentFetchCanister: Principal,
    _likeFetchCanister: Principal
) = this {
    // ...
};
```

<br>

æ•´ä½“ä¸Šè¿™ä¸ª Bucket ç”¨äºæ¥æ”¶å„ç§æ“ä½œï¼ˆæ–°è¯„è®ºã€ç‚¹èµç­‰ï¼‰æ¥æ›´æ–°å¸–å­ï¼Œæ‰€æœ‰æ•°æ®ä»¥ä¸å¯å˜å½¢å¼å­˜å‚¨ï¼Œå¯ä»¥é«˜æ•ˆåœ°è¿›è¡ŒæŸ¥è¯¢å’Œå…±äº«ã€‚

é¦–å…ˆå®šä¹‰ä¸€äº›ç±»å‹ã€å˜é‡å’Œæ•°æ®ç»“æ„ã€‚

```js
// å®šä¹‰äº†å‡ ä¸ªç±»å‹åˆ«å
type FeedActor = Types.FeedActor;
type PostImmutable = Types.PostImmutable;
type NewComment = Types.NewComment;
type NewLike = Types.NewLike;
type NewRepost = Types.NewRepost;
type CommentFetchActor = Types.CommentFetchActor;
type LikeFetchActor = Types.LikeFetchActor;
type RootPostActor = Types.RootPostActor;

stable let BUCKET_MAX_POST_NUMBER: Nat = 5000; // æ¯ä¸ªBucketå¯ä»¥å­˜å‚¨çš„æœ€å¤§å¸–å­æ•°
stable let FLOOR_BUCKET_MAX_POST_NUMBER: Nat = BUCKET_MAX_POST_NUMBER - 50; // ä¸€ä¸ªä¸‹é™é˜ˆå€¼

stable let installer = msg.caller;

// postId -> PostImmutable
// ä¸»è¦çš„æ•°æ®å­˜å‚¨åœ¨feedMapä¸­ï¼Œè¿™æ˜¯ä¸€ä¸ªä»å¸–å­IDåˆ°PostImmutableçš„æ˜ å°„
stable var feedMapEntries: [(Text, PostImmutable)] = [];
// å­˜å‚¨åœ¨TrieMapä¸­ï¼Œä½¿ç”¨Textå“ˆå¸Œå’Œæ¯”è¾ƒ
let feedMap = TrieMap.fromEntries<Text, PostImmutable>(feedMapEntries.vals(), Text.equal, Text.hash);
```

`TrieMap` æ˜¯ä¸€ç§é«˜æ•ˆçš„é”®å€¼å­˜å‚¨ç»“æ„ã€‚ä½¿ç”¨ `TrieMap` ç»´æŠ¤äº†å¸–å­ä¿¡æ¯ï¼Œæä¾›äº†å­˜å‚¨ã€æ‰¹é‡å­˜å‚¨ã€æ›´æ–°è¯„è®ºã€æ›´æ–°ç‚¹èµã€æ›´æ–°è½¬å‘ç­‰åŠŸèƒ½ã€‚`feedMapEntries` å’Œ `feedMap` çš„å®šä¹‰ç”¨æ¥å­˜å‚¨å¸–å­æ•°æ®ï¼Œä¸€ä¸ªæ˜¯æ•°ç»„å½¢å¼ï¼Œä¸€ä¸ªæ˜¯ TrieMap å½¢å¼ã€‚

<br>

å­˜å‚¨å¸–å­ï¼š

`storeFeed()` å‡½æ•°ç”¨æ¥å­˜å‚¨å•ä¸ªå¸–å­ã€‚å®ƒæ˜¯ `public shared` çš„ï¼Œæ‰€ä»¥å¯ä»¥è¢«å¤–éƒ¨è°ƒç”¨è€…è°ƒç”¨ã€‚

```js
public shared({caller}) func storeFeed(post: PostImmutable): async Bool {
    ignore checkBucketMemory();
    _storeFeed(post);
};
```

`batchStoreFeed()` ç”¨äºæ‰¹é‡å­˜å‚¨å¤šç¯‡å¸–å­ï¼Œå†…éƒ¨ä½¿ç”¨å¾ªç¯è°ƒç”¨ `_storeFeed()` é€ä¸ªå­˜å‚¨ã€‚

```js
public shared({caller}) func batchStoreFeed(posts: [PostImmutable]): async () {
    for(post in posts.vals()) {
        ignore _storeFeed(post);
    };
};
```

`updatePostRepost()` ç”¨æ¥æ›´æ–°ä¸€ä¸ªå¸–å­çš„è½¬å‘ä¿¡æ¯ã€‚å®ƒä¼šè°ƒç”¨ `_updatePostRepost()` æ‰§è¡Œå®é™…çš„æ›´æ–°ï¼Œå¹¶ assert ç¡®ä¿æ›´æ–°æˆåŠŸã€‚

```js
public shared({caller}) func updatePostRepost(postId: Text, newRepost: NewRepost): async Bool {
    assert(_updatePostRepost(postId, newRepost));
    true
};
```

`_storeFeed()` å’Œ `_updatePostRepost()` æ˜¯ç§æœ‰å‡½æ•°ï¼Œæ˜¯å®é™…å®ç°å­˜å‚¨å’Œæ›´æ–°çš„å†…éƒ¨é€»è¾‘ã€‚

<br>

æ¥ä¸‹æ¥æ˜¯æ›´æ–°å¸–å­è¯„è®ºå’Œç‚¹èµçš„åŠŸèƒ½ï¼š

`updatePostComment` å‡½æ•°ç”¨äºæ›´æ–°å¸–å­çš„è¯„è®ºä¿¡æ¯ã€‚å®ƒæ¥æ”¶å¸–å­ ID å’Œæ–°çš„è¯„è®ºä½œä¸ºå‚æ•°ã€‚å†…éƒ¨è°ƒç”¨ `_updatePostComment` å‡½æ•°å»å®é™…æ‰§è¡Œè¯„è®ºçš„æ›´æ–°ã€‚

æ›´æ–°æˆåŠŸåï¼Œä¼šä» `_updatePostComment` è¿”å›æ›´æ–°åçš„ post å¯¹è±¡ã€‚ç„¶åé€šçŸ¥ `CommentFetchActor` å»æ›´æ–°è¯„è®ºç¼“å­˜ã€‚

`updatePostLike` å‡½æ•°ç”¨äºæ›´æ–°å¸–å­çš„ç‚¹èµä¿¡æ¯ã€‚å®ƒæ¥æ”¶å¸–å­ ID å’Œæ–°çš„ç‚¹èµä½œä¸ºå‚æ•°ã€‚å†…éƒ¨è°ƒç”¨ `_updatePostLike` å»å®é™…æ‰§è¡Œç‚¹èµçš„æ›´æ–°ã€‚ 

æ›´æ–°æˆåŠŸåï¼ŒåŒæ ·è¿”å›æ›´æ–°åçš„ post å¯¹è±¡ï¼Œå¹¶é€šçŸ¥ `LikeFetchActor` å»æ›´æ–°ç‚¹èµç¼“å­˜ã€‚

```js
// æ›´æ–°å¸–å­è¯„è®ºä¿¡æ¯
// callerå‚æ•°è¡¨ç¤ºï¼šåªæœ‰è°ƒç”¨è€…çš„è¯·æ±‚ä¸­ç»™å‡ºæ­£å¸¸èº«ä»½ï¼Œæ‰èƒ½è°ƒç”¨å‡½æ•°
public shared({caller}) func updatePostComment(postId: Text, newComment: NewComment): async Bool {
    switch(_updatePostComment(postId, newComment)) {
        case(null) { return false; };
        case(?_post) {
            // é€šçŸ¥ commentFetch
            let commentFetchActor: CommentFetchActor = actor(Principal.toText(commentFetchCanister));
            ignore commentFetchActor.receiveNotify(_post);
        };
    };
    // è¿”å›Boolå€¼è¡¨ç¤ºæ›´æ–°æ˜¯å¦æˆåŠŸ
    true
};

public shared({caller}) func updatePostLike(postId: Text, newLike: NewLike): async Bool {
    switch(_updatePostLike(postId, newLike)) {
        case(null) { return false; };
        case(?_post) {
            // é€šçŸ¥ likeFetch
            let likeFetchActor: LikeFetchActor = actor(Principal.toText(likeFetchCanister));
            ignore likeFetchActor.receiveNotify(_post);
        };     
    };
    true
};
```

æˆ‘ä»¬é€šè¿‡ç§æœ‰å‡½æ•°å®ç°å¯¹æ“ä½œå¸–å­å‡½æ•°çš„å°è£…ã€‚å¤–éƒ¨åªéœ€è¦è°ƒç”¨å…¬å¼€çš„ update å‡½æ•°ï¼Œä¸éœ€è¦å…³å¿ƒå†…éƒ¨çš„å­˜å‚¨å’Œæ›´æ–°é€»è¾‘ã€‚ ç§æœ‰å‡½æ•°å¯ä»¥å°è£…çŠ¶æ€ç®¡ç†ï¼Œä½¿ä»£ç æ›´åŠ æ¨¡å—åŒ–å’Œå¯ç»´æŠ¤ã€‚

<br>

`_updatePostComment` å‡½æ•°ç”¨äºæ›´æ–°å¸–å­çš„è¯„è®ºã€‚å®ƒä» `feedMap` ä¸­è·å–åŸæœ‰çš„å¸–å­ï¼Œç”¨æ–°è¯„è®º `newComment` æ›´æ–° `comment` å­—æ®µï¼Œå¹¶ put å›`feedMap` ã€‚

`feedMap` æ˜¯ä¸€ä¸ªå­˜å‚¨å¸–å­çš„å“ˆå¸Œè¡¨ï¼Œkey æ˜¯ `postId` ï¼Œvalue æ˜¯ `PostImmutable` è®°å½•ã€‚

```js
private func _updatePostComment(postId: Text, newComment: NewComment): ?PostImmutable {
    switch(feedMap.get(postId)) {
        case(null) { return null; };
        case(?post) {
            let _newPost = {
                postId = post.postId;
                feedCanister = post.feedCanister;
                index = post.index;
                user = post.user;
                repost = post.repost;
                content = post.content;
                like = post.like;
                comment = newComment;
                createdAt = post.createdAt;
            };
            feedMap.put(postId, _newPost);
            ?_newPost
        };
    };
};
```

<br>

`_updatePostLike` ç±»ä¼¼åœ°æ›´æ–°å¸–å­çš„ç‚¹èµ like å­—æ®µã€‚ 

```js
private func _updatePostLike(postId: Text, newLike: NewLike): ?PostImmutable {
    switch(feedMap.get(postId)) {
        case(null) { return null; };
        case(?post) {
            let _newPost = {
                postId = post.postId;
                feedCanister = post.feedCanister;
                index = post.index;
                user = post.user;
                repost = post.repost;
                content = post.content;
                like = newLike;
                comment = post.comment;
                createdAt = post.createdAt;
            };
            feedMap.put(postId, _newPost);
            ?_newPost              
        };
    };
};
```

<br>

`_updatePostRepost` æ›´æ–°å¸–å­çš„è½¬å‘ repost å­—æ®µã€‚

```js
private func _updatePostRepost(postId: Text, newRepost: NewRepost): Bool {
    switch(feedMap.get(postId)) {
        case(null) { return false; };
        case(?post) {
            feedMap.put(postId, {
                postId = post.postId;
                feedCanister = post.feedCanister;
                index = post.index;
                user = post.user;
                content = post.content;
                repost = newRepost;
                like = post.like;
                comment = post.comment;
                createdAt = post.createdAt;
            });
            true
        };
    };
};
```

<br>

ä½¿ç”¨ `immutable` æ•°æ®ç»“æ„ `PostImmutable` å¯ä»¥ä¿è¯æ•°æ®ä¸€è‡´æ€§ï¼Œé¿å…æ„å¤–ä¿®æ”¹ã€‚

```js
// æŠŠæ–°çš„å¸–å­ä¿å­˜åˆ°feedMapä¸­
// æ£€æŸ¥postIdæ˜¯å¦å·²å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨æ‰ä¿å­˜ï¼Œé¿å…é‡å¤
private func _storeFeed(post: PostImmutable): Bool {
    ignore Utils.checkPostId(post.postId);
    switch(feedMap.get(post.postId)) {
        case(?_post) {
            // Debug.print("This post has been stored");
            return false;
        };
        case(null) {
            feedMap.put(post.postId, post);
            return true;
        };
    };
};
```

<br>

`checkBucketMemory` å‡½æ•°ç”¨äºæ£€æŸ¥å½“å‰ Bucket æ˜¯å¦æ¥è¿‘å®¹é‡ä¸Šé™ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™é€šçŸ¥æ ¹å¸–å­ Actor åˆ›å»ºæ–°çš„ Bucket ã€‚

```js
func checkBucketMemory(): async () {
    if(feedMap.size() > FLOOR_BUCKET_MAX_POST_NUMBER) {
        let rootPostActor: RootPostActor = actor(Principal.toText(rootPostCanister));
        ignore rootPostActor.reCreateBucket();
    }
};
```

<br>

æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæŸ¥è¯¢å¸–å­æ€»æ•°çš„å‡½æ•°ï¼š

```js
// æŸ¥è¯¢å…±æœ‰å¤šå°‘ä¸ªå¸–å­
public query func getPostNumber(): async Nat {
    feedMap.size()
};
```

<br>

è¿˜æœ‰è·å–å¸–å­å…·ä½“å†…å®¹çš„å‡½æ•°ï¼Œå®ç°å¿«é€Ÿæ‰¹é‡è·å–æŸå‡ ä¸ªå¸–å­çš„åŠŸèƒ½ã€‚

è¿™ä¸ªåŠŸèƒ½ç”¨åœ¨ Feed Canister æŠ“å–å¸–å­ä¸Šï¼š

å½“ç”¨æˆ·å…³æ³¨çš„æŸå‡ ä¸ªäººå‘å¸ƒäº†å¸–å­ï¼Œè¿™äº›å¸–å­çš„ ID åˆä¼šè¢«é€åˆ° Fetch ï¼Œæœ€åå‘é€åˆ° å¦ä¸€ä¸ª Feed é‡Œã€‚è¿™æ˜¯ Feed å°±ä¼šä¸€æ¬¡æ€§æ”¶åˆ°å¾ˆå¤šä¸ªå¸–å­çš„ ID ï¼ŒFeed å°±éœ€è¦æŠŠè¿™äº›å¸–å­ ID å‘ç»™ Bucket ï¼Œä¸€æ¬¡æ€§è·å–åˆ°è¿™äº›å¸–å­ä»¬ã€‚

```js
// æ ¹æ®IDæŸ¥è¯¢æŸå‡ ä¸ªå¸–å­ï¼ˆå¯ä»¥ä¼ å…¥7ä¸ªIDä¸€æ¬¡æ€§è¿”å›7ä¸ªå¸–å­çš„å†…å®¹ï¼‰
public query func getPosts(postIdArray: [Text]): async [PostImmutable] { // æ¥æ”¶ä¸€ä¸ªTextæ•°ç»„postIdArrayä½œä¸ºå‚æ•°
    // åˆ›å»ºä¸€ä¸ªBufferæ¥å­˜å‚¨æŸ¥è¯¢ç»“æœï¼Œå¤§å°ä¸ºpostIdArrayçš„å¤§å°
    let result = Buffer.Buffer<PostImmutable>(postIdArray.size());
    // éå†postIdArrayä¸­çš„æ¯ä¸ªID
    for(postId in postIdArray.vals()) {
        // å¯¹æ¯ä¸ªIDï¼Œä»feedMapä¸­æŸ¥æ‰¾ï¼Œå¦‚æœæ‰¾åˆ°åˆ™æ”¾å…¥ç»“æœBufferä¸­
        switch(feedMap.get(postId)) {
            case(null) {};
            case(?post) { result.add(post); };
        };
    };
        // éå†ç»“æŸåï¼Œé€šè¿‡toArray()è½¬æ¢Bufferä¸ºæ•°ç»„å¹¶è¿”å›
        Buffer.toArray<PostImmutable>(result)
};
```

æˆ‘ä»¬ä½¿ç”¨ Buffer é¿å…å¤šæ¬¡æ•°ç»„æ‹¼æ¥çš„å¼€é”€ã€‚query å‡½æ•°å¯ä»¥è¢«é“¾å¤–è°ƒç”¨ï¼Œå®ç°äº†æ•°æ®æŸ¥è¯¢çš„å°è£…ã€‚ è¿”å›çš„æ˜¯æ•°ç»„ç±»å‹ï¼Œè°ƒç”¨æ–¹å¯ä»¥æ–¹ä¾¿å¤„ç†æŸ¥è¯¢ç»“æœã€‚

è¿™æ ·å°±å¯ä»¥æ‰¹é‡æŸ¥è¯¢å¤šç¯‡å¸–å­å†…å®¹äº†ã€‚

<br>

æ ¹æ® ID æ‰¹é‡ç²¾ç¡®æŸ¥è¯¢å¸–å­ä¹‹åï¼Œè¿˜éœ€è¦ 2 ä¸ªå…³äºæŸ¥è¯¢çš„å‡½æ•°ï¼šæ ¹æ® ID å•ç‹¬æŸ¥è¯¢å¸–å­çš„å‡½æ•°å’ŒæŸ¥è¯¢æœ€æ–°çš„ n ä¸ªå¸–å­å‡½æ•°ã€‚

```js
public query func getPost(postId: Text): async ?PostImmutable {
    switch(feedMap.get(postId)) {
        case(null) { return null; };
        case(?post) { return ?post; }; 
    };
};

// æŸ¥è¯¢æœ€æ–°çš„ n ä¸ªå¸–å­
public query func getLatestFeed(n: Nat): async [PostImmutable] {
    let feedArray = Iter.toArray(
        Iter.sort<PostImmutable>(
        feedMap.vals(),
        func (x: PostImmutable, y: PostImmutable): Order.Order {
            if(x.createdAt > y.createdAt) return #less
            else if(x.createdAt < y.createdAt) return #greater
            else return #equal
    }));
    if(n <= feedArray.size()) {
        Array.subArray(feedArray, 0, n)
    } else {
        Array.subArray(feedArray, 0, feedArray.size())
    }
};
```

æœ€åæ˜¯å’Œå‡çº§æœ‰å…³çš„ç³»ç»Ÿå‡½æ•°ï¼Œé€šè¿‡ `preupgrade` å’Œ `postupgrade` å‡½æ•°ç®¡ç† Bucket çš„çŠ¶æ€ã€‚

<br>

ä»¥ä¸‹æ˜¯ bucket.mo å®Œæ•´æ–‡ä»¶ï¼š

```js
import Types "./types";
import TrieMap "mo:base/TrieMap";
import Principal "mo:base/Principal";
import Array "mo:base/Array";
import Order "mo:base/Order";
import Text "mo:base/Text";
import Hash "mo:base/Hash";
import Nat "mo:base/Nat";
import Iter "mo:base/Iter";
import Debug "mo:base/Debug";
import Option "mo:base/Option";
import Buffer "mo:base/Buffer";
import Utils "../utils";

shared(msg) actor class Bucket(
    rootPostCanister: Principal,
    _commentFetchCanister: Principal,
    _likeFetchCanister: Principal
) = this {
    
    type FeedActor = Types.FeedActor;
    type PostImmutable = Types.PostImmutable;
    type NewComment = Types.NewComment;
    type NewLike = Types.NewLike;
    type NewRepost = Types.NewRepost;
    type CommentFetchActor = Types.CommentFetchActor;
    type LikeFetchActor = Types.LikeFetchActor;
    type RootPostActor = Types.RootPostActor;

    stable let BUCKET_MAX_POST_NUMBER: Nat = 5000; // æ¯ä¸ªBucketå¯ä»¥å­˜å‚¨çš„æœ€å¤§å¸–å­æ•° (å¾…è®¡ç®—)
    stable let FLOOR_BUCKET_MAX_POST_NUMBER: Nat = BUCKET_MAX_POST_NUMBER - 50;

    stable let installer = msg.caller;

    // postId -> PostImmutable
    stable var feedMapEntries: [(Text, PostImmutable)] = [];
    let feedMap = TrieMap.fromEntries<Text, PostImmutable>(feedMapEntries.vals(), Text.equal, Text.hash);

    // å­˜å‚¨å¸–å­
    public shared({caller}) func storeFeed(post: PostImmutable): async Bool {
        ignore checkBucketMemory();
        _storeFeed(post);
    };

    public shared({caller}) func batchStoreFeed(posts: [PostImmutable]): async () {
        for(post in posts.vals()) {
            ignore _storeFeed(post);
        };
    };

    public shared({caller}) func updatePostRepost(postId: Text, newRepost: NewRepost): async Bool {
        assert(_updatePostRepost(postId, newRepost));
        true
    };

    // æ›´æ–°å¸–å­è¯„è®ºä¿¡æ¯ 
    public shared({caller}) func updatePostComment(postId: Text, newComment: NewComment): async Bool {
        switch(_updatePostComment(postId, newComment)) {
            case(null) { return false; };
            case(?_post) {
                // é€šçŸ¥ commentFetch
                let commentFetchActor: CommentFetchActor = actor(Principal.toText(commentFetchCanister));
                ignore commentFetchActor.receiveNotify(_post);
            };
        };
        true
    };

    public shared({caller}) func updatePostLike(postId: Text, newLike: NewLike): async Bool {
        switch(_updatePostLike(postId, newLike)) {
            case(null) { return false; };
            case(?_post) {
                // é€šçŸ¥ likeFetch
                let likeFetchActor: LikeFetchActor = actor(Principal.toText(likeFetchCanister));
                ignore likeFetchActor.receiveNotify(_post);
            };     
        };
        true
    };

    func checkBucketMemory(): async () {
        if(feedMap.size() > FLOOR_BUCKET_MAX_POST_NUMBER) {
            let rootPostActor: RootPostActor = actor(Principal.toText(rootPostCanister));
            ignore rootPostActor.reCreateBucket();
        }
    };

    private func _updatePostComment(postId: Text, newComment: NewComment): ?PostImmutable {
        switch(feedMap.get(postId)) {
            case(null) { return null; };
            case(?post) {
                let _newPost = {
                    postId = post.postId;
                    feedCanister = post.feedCanister;
                    index = post.index;
                    user = post.user;
                    repost = post.repost;
                    content = post.content;
                    like = post.like;
                    comment = newComment;
                    createdAt = post.createdAt;
                };
                feedMap.put(postId, _newPost);
                ?_newPost
            };
        };
    };

    private func _updatePostLike(postId: Text, newLike: NewLike): ?PostImmutable {
        switch(feedMap.get(postId)) {
            case(null) { return null; };
            case(?post) {
                let _newPost = {
                    postId = post.postId;
                    feedCanister = post.feedCanister;
                    index = post.index;
                    user = post.user;
                    repost = post.repost;
                    content = post.content;
                    like = newLike;
                    comment = post.comment;
                    createdAt = post.createdAt;
                };
                feedMap.put(postId, _newPost);
                ?_newPost              
            };
        };
    };

    private func _updatePostRepost(postId: Text, newRepost: NewRepost): Bool {
        switch(feedMap.get(postId)) {
            case(null) { return false; };
            case(?post) {
                feedMap.put(postId, {
                    postId = post.postId;
                    feedCanister = post.feedCanister;
                    index = post.index;
                    user = post.user;
                    content = post.content;
                    repost = newRepost;
                    like = post.like;
                    comment = post.comment;
                    createdAt = post.createdAt;
                });
                true              
            };
        };
    };

    private func _storeFeed(post: PostImmutable): Bool {
        ignore Utils.checkPostId(post.postId);
        switch(feedMap.get(post.postId)) {
            case(?_post) {
                // Debug.print("This post has been stored");
                return false;
            };
            case(null) {
                feedMap.put(post.postId, post);
                return true;
            };
        };
    };

// ==================== æŸ¥è¯¢å‡½æ•° ====================

    // æŸ¥è¯¢å…±æœ‰å¤šå°‘ä¸ªå¸–å­
    public query func getPostNumber(): async Nat {
        feedMap.size()
    };

    // æ ¹æ®IDæŸ¥è¯¢æŸå‡ ä¸ªå¸–å­ï¼ˆå¯ä»¥ä¼ å…¥ 7 ä¸ª ID ä¸€æ¬¡æ€§è¿”å› 7 ä¸ªå¸–å­çš„å†…å®¹ï¼‰
    public query func getPosts(postIdArray: [Text]): async [PostImmutable] {
       let result = Buffer.Buffer<PostImmutable>(postIdArray.size());
       for(postId in postIdArray.vals()) {
        switch(feedMap.get(postId)) {
            case(null) {};
            case(?post) { result.add(post); };
        };
       };
       Buffer.toArray<PostImmutable>(result)
    };

    public query func getPost(postId: Text): async ?PostImmutable {
        switch(feedMap.get(postId)) {
            case(null) { return null; };
            case(?post) { return ?post; }; 
        };
    };

    // æŸ¥è¯¢æœ€æ–°çš„ n ä¸ªå¸–å­
    public query func getLatestFeed(n: Nat): async [PostImmutable] {
        let feedArray = Iter.toArray(
            Iter.sort<PostImmutable>(
            feedMap.vals(),
            func (x: PostImmutable, y: PostImmutable): Order.Order {
                if(x.createdAt > y.createdAt) return #less
                else if(x.createdAt < y.createdAt) return #greater
                else return #equal
        }));
        if(n <= feedArray.size()) {
            Array.subArray(feedArray, 0, n)
        } else {
            Array.subArray(feedArray, 0, feedArray.size())
        }
    };

// ==================== CommentFetchCanister ====================

    stable var commentFetchCanister = _commentFetchCanister;
    
    public query func getCommentFetchCanister(): async Principal { commentFetchCanister };

    public shared({caller}) func updateCommentFetchCanister(
        newCommentFetchCanister: Principal
    ): async () {
        commentFetchCanister := commentFetchCanister;
    };


// ==================== LikeFetchCanister ====================

    stable var likeFetchCanister = _likeFetchCanister;
    
    public query func getLikeFetchCanister(): async Principal { likeFetchCanister };

    public shared({caller}) func updateLikeFetchCanister(
        newLikeFetchCanister: Principal
    ): async () {
        likeFetchCanister := newLikeFetchCanister;
    };

    system func preupgrade() {
        feedMapEntries := Iter.toArray(feedMap.entries());
    };

    system func postupgrade() {
        feedMapEntries := [];
    };
}
```

ç„¶åæ˜¯ [Feed æ¨¡å—](./6.Feedæ¨¡å—.md)ã€‚



